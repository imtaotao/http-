# 4.连接管理
本章内容主要介绍如下：

- HTTP 是如何使用 TCP 连接的
- TCP 连接的时延、瓶颈以及存在的障碍
- HTTP 的优化，包括并行连接、keep-alive（持久连接）和管道化连接
- 管理连接时应该以及不应该做的事情

## TCP 连接
例如：`http://www.joes-hardware.com:80/power-tools.html`<br>
浏览器收到一个 URL 会执行以下步骤：<br>

> 浏览器解析出主机名（www.joes-hardware.com）
> 浏览器查询这个主机名的 IP 地址（DNS --> 202.43.78.3)
> 浏览器获得端口号（80）
> 浏览器发送到 202.43.78 端口 80 的连接
> 浏览器向服务器发送一条 HTTP GET 报文
> 浏览器从服务器读取 HTTP 响应报文
> 浏览器关闭连接

+ **TCP 流是分段的、由 IP 分组传送**<br>
TCP 为 HTTP 提供了一条可靠的比特传输管道。从 TCP 连接一端填入的字节会从另一端以原有的顺序、正确地传送出来。TCP 的数据是通过名为 IP 分组（或 IP 数据报）的小数据块来发送的。这样的话，HTTP 就是 `HTTP over TCP over IP` 这个 “协议栈” 中的最顶层了。其安全版本 HTTPS 就是在 HTTP 和 TCP 之间插入了一个（称为 TLS 或 SSL 的）密码加密层。<br>
HTTP 要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的 TCP 连接按序传输。TCP 收到数据流之后，会将数据流砍成被称作段的小数据块，并将段封装在 IP 分组中，通过因特网进行传输。<br>
每个 TCP 段都是由 IP 分组承载，从一个 IP 地址发送到另一个 IP 地址的，每个 IP 分组中都包括：
  1. 一个 IP 分组首部（通常为 20 字节）
  2. 一个 TCP 段首部（通常为 20 字节）
  3. 一个 TCP 数据块（0 个或多个字节）


<br><br>
+ **保持 TCP 连接的持续不断地运行**<br>
在任意时刻计算机都有可以几条 TCP 连接处于打开状态。TCP 连接是通过 4 个值来识别的：
```
  <源 IP 地址、源端端口号、目的 IP 地址、目的端口号>
```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
这四个值一起唯一地定义了一条连接。两条不同的 TCP 连接不能拥有 4 个完全相同的地址组件值


<br><br>
+ **用 TCP 套接字编程**<br>
操作系统提供了一些操作其 TCP 连接的工具。套接字 API 允许用户创建 TCP 的端点数据结构，将这些端点与远程服务器的 TCP 端点进行连接，并对数据流进行写入。以下为常见的套接字接口函数：

| 套接字 API 调用                   | 描述                     |
|------------------------------|------------------------|
| s = socket(<parameters>)     | 创建一个新的、未命名、未关联的套接字     |
| bind(s, <local IP:port>)     | 向套接字赋一个本地端口号和接口        |
| connect(s, <remote IP:port>) | 创建一条连接本地套接字与远程主机及端口的连接 |
| listen(s, ...)               | 标识一个本地套接字，使其可以合法接受连接   |
| s2 = accept(s)               | 等待某人建立一条到本地端口的连接       |
| n = read(s, buffer, n)       | 尝试从套接字向缓冲区读取 n 个字节     |
| n = write(s, buffer, n)      | 尝试从缓冲区中向套接字写入 n 个字节    |
| close(s)                     | 完全关闭 TCP 连接            |
| shutdown(s, <side>)          | 值关闭 TCP 连接的输入或输出端      |
| getsockopt(s, ...)           | 读取某个内部套接字配置选项的值        |
| setsockopt(s, ...)           | 修改某个内部套接字配置选项的值        |

```
      ---------                                  ---------
      | 客户端 |                                  | 服务器 |
      ---------                                  ---------

                                                （S1）创建新的套接字（socket）
                                                （S2) 将套接字绑定到端口 80 上去（bind）
                                                （S3）允许套接字进行连接（listen）
                                                （S4）等待连接（accept）
                                                           |
      （C1）获取 IP 地址和端口号                              |
      （C2）创建新的套接字（socket）。                         |
      （C3）连接到服务器 IP:port 上去（connect）  -----        |
         |                                        |        |
         |                                        V        |
         |     -------------------------------- （S5）通知应用程序有连接到来
         |     |                                （S6）开始读取请求（read）
         |     v                                           |
      （C4）连接成功                                         |
      （C5）发送 HTTP 请求（write） ------------------        |
      （C6）等待 HTTP 响应（read）。                 |        |
         |                                        V        |
         |                                      （S7）处理 HTTP 请求报文
         |    --------------------------------- （S8）回送 HTTP 响应（write）
         |    |                                 （S9）关闭连接（close）
         |    V
      （C7）处理 HTTP 响应
      （C8）关闭连接（close）
```


## 对 TCP 性能考虑
HTTP 紧挨着 TCP，位于其上层，所以 HTTP 事务的性能在很大程度上取决于底层 TCP 通道的性能

+ **HTTP 事物的时延**<br>
HTTP 事务的时延有以下几种主要原因：
  1. 客户端首先需要根据 URL 确定 web 服务器的 IP 地址和端口号。如果最近没有对 URL 中的主机名进行访问，需要通过 DNS 解析，而 DNS 解析可能花费数十秒时间（大多数浏览器有 DNS 缓存）

  2. 接下来客户端会向服务器发送一条 TCP 连接请求，并等待服务器回送一个请求接受应答。每条新的 TCP 连接都会有连接建立时延。这个值最多只有一两秒种。但是如果有数百个 HTTP 事务，这个值会快速叠加上去

  3. 一旦连接建立起来了，客户端会通过建立新的 TCP 管道来发送 HTTP 请求。数据到达，服务器读取报文，处理请求。因特网传输报文等都需要时间

  4. 然后，服务器回送 HTTP 响应，也需要花费时间


<br><br>
+ **性能聚焦区域**<br>
一些常见的 TCP 相关时延，包括：
  + TCP 连接建立握手
  + TCP 慢启动拥塞控制
  + 数据聚焦的 Nagle 算法
  + 捎带确认的 TCP 延迟确认算法
  + TIME_WAIT 时延和端口耗尽


<br><br>
+ **TCP 连接的握手时延（经典的 tcp 三次握手）**<br>
TCP 连接握手需要经过以下几个步骤：
  1. 请求新的 TCP 连接时，客户端要向服务器发送一个小的 TCP 分组（通常是 40 ~ 60 个字节）。这个分组设置了一个特殊的 SYN 标记，说明这是一个请求

  2. 如果服务器接受了请求，就会对一些连接参数进行计算，并向客户端回送一个 TCP 分组，这个分组中的 SYN 和 ACK 标记都被置位，说明请求已被接受

  3. 最后，客户端向服务器回送一条确认消息，通知它连接已成功建立。现代的 TCP 栈都允许客户端在这个确认分组中发送数据

```
  ---------
  | 服务器 |  -------------|--------------------------------------------------------------->
  ---------          (a) SYN  _             (c) ACK
                      -        -                GET/HTTP...
                    —            -          -             -
                  —                -      -                 -
  ---------     —             (b) SYN + ACK                    (d) HTTP/1.1 304 Not modified
  | 客户端 |  ---|---------------------|-------------------------|--------------------------->
  ---------    连接   连接握手时延                 数据传输                                   time


  常 HTTP 事务都不会交换太多数据，此时，SYN/SYN+ACK 握手会产生一个可测量的时延
  小的 HTTP 事务可能会在 TCP 连接上花费 50%，甚至更多
```


<br><br>
+ **延迟确认**<br>
由于因特网自身无法确保可靠的分组传输，所以 TCP 实现了自己的确认机制。每个 TCP 段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的时段，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者就任务数据已经被破坏损毁，并重发数据。<br>
由于确认报文很小，所以 TCP 允许在发往相同反向的输出数据分组中对其进行 “捎带”。TCP 将返回的确认信息与输出的数据分组结合在一起，可以更有效地利用网络（利用空间换因特网传输时间，但这个只针对大块数据传输的情况下）。**为了增加确认报文找到同向传输数据分组的可能性，很多 TCP 栈实现了一种 “延迟确认” 算法**。延迟确认算法会在一个特定的窗口时间（通常是 100 ～ 200 毫秒）内将输出确认存放在缓冲区中，以寻找能够捎带它的输出数据分组。如果那个时间段没有输出数据分组，就将确认信息放在单独的分组中传送。<br>
但是 HTTP 具有双峰特征的请求（请求、响应）降低了捎带信息的可能（有可能没有要传输的数据，那么确认就必须在延时之后独自发送）。延迟确认算法会引入相当大的时延。根据所使用操作系统的不同，可以调整或禁止延迟确认算法


<br><br>
+ **TCP 慢启动**<br>
TCP 数据传输的性能还取决于 TCP 连接的使用期（age）。TCP 连接会随着时间进行自我 “调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐被称为 TCP 慢启动，用于防止因特网的突然过载和拥塞。<br>
TCP 慢启动限制了一个 TCP 端点在任意时刻可以传输的分组数。简单来说，每成功接收一个分组，发送端就有了发送另外两个分组的权限。**如果某个 HTTP 事务有大量数据要发送，是不能一次将所有分组都发送出去的**。必须发送一个分组，等待确认；然后可以发送两个分组，每个分组都必须被确认，这样就可以发送四个分组了，以此类推。这种方式被称为 “打开拥塞窗口”。所以**新连接的传输速度会比已经交换过一定量数据的、“已调谐” 连接慢一些”**


<br><br>
+ **Nagle 算法与 TCP_NODELAY**<br>
TCP 有一个数据流接口，应用程序可以通过它将任意尺寸的数据放入 TCP 栈中，所以如果 TCP 发送大量包含少量数据的分组，网络性能会严重下降。<br>
“Nagle 算法试图在发送一个分组之前，将大量 TCP 数据绑定在一起，以提高网络效率。RFC 896“IP/TCP 互连网络中的拥塞控制”对此算法进行了描述。Nagle 算法鼓励发送全尺寸（LAN 上最大尺寸的分组大约是 1500 字节，在因特网上是几百字节）的段。只有当所有其他分组都被确认之后，Nagle 算法才允许发送非全尺寸的分组。如果其他分组仍然在传输过程中，就将那部分数据缓存起来。只有当挂起分组被确认（延迟确认），或者缓存中积累了足够发送一个全尺寸分组的数据时，才会将缓存的数据发送出去。<br>
Nagle 算法会引发几种 HTTP 性能问题：

  + 小的 HTTP 报文可能无法填满一个分组，可能会因为等待那些永远不会到来的额外数据而产生时延
  + Nagle 算法与延迟确认之间的交互存在问题 —— Nagle 算法会阻止数据的发送，直到有确认分组抵达为止，但确认分组自身会被延迟确认算法延迟 100 ～ 200 毫秒

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
HTTP 应用程序常常会在自己的栈中设置参数 TCP_NODELAY，禁用 Nagle 算法，提高性能


<br><br>
+ **TIME_WAIT 累积与端口耗尽**<br>
当某个 TCP 端点关闭 TCP 连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的 IP 地址和端口号。这类信息只会维持一小段时间，通常是所估计的最大分段使用期的两倍（称为 2MSL，通常为 2 分钟，有的会改为更小的值）左右，以确保在这段时间内不会创建具有相同地址和端口号的新连接。实际上，这个算法可以防止在两分钟内创建、关闭并重新创建两个具有相同 IP 地址和端口号的连接。<br>
在只有一台或几台用来产生流量的计算机连接到某系统中时，会限制了连接到服务器的客户端 IP 地址数，这样就限制了可以用的连接值组合

```
  <source-IP-address, source-port, destination-IP-address, destination-port>


  其中的 3 个都是固定的——只有源端口号可以随意改变：
  <client-IP, source-port, server-IP, 80>
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
客户端每次连接到服务器上去时，都会获得一个新的源端口，以实现连接的唯一性。但由于可用源端口的数量有限（比如，60 000 个），而且在 2MSL 秒（比如，120 秒）内连接是无法重用的，连接率就被限制在了 60 000/120=500 次 / 秒。如果再不断进行优化，并且服务器的连接率不高于 500 次 / 秒，就可确保不会遇到 TIME_WAIT 端口耗尽问题


<br><br>
## HTTP 连接的处理
+ **常被误解的 Connection 首部**<br>
HTTP 的 Connection 首部字段中有一个由逗号分隔的连接标签列表，这些标签为此连接指定了一些不会传播到其他连接中去的选项。比如，可以用 Connection:close 来说明发送完下一条报文之后必须关闭的连接。Connection 首部可以承载 3 种不同类型的标签：
  + HTTP 首部字段名，列出了只与此连接有关的首部
  + 任意标签值，用于描述此连接的非标准选项
  + 值 close，说明操作完成之后需关闭这条持久连接

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
如果连接标签中包含了一个 HTTP 首部字段的名称，那么这个首部字段就包含了与一些连接有关的信息，不能将其转发出去。在将报文转发出去之前，必须删除 Connection 首部列出的所有首部字段。由于 Connection 首部可以防止无意中对本地首部的转发，因此将逐跳首部名放入 Connection 首部被称为 “对首部的保护”。还会有一些一定不能被代理转发的逐跳首部（有关 Connection 首部详情见附录 C）。其中包括：
  + Prxoy-Authenticate
  + Proxy-Connection
  + Transfer-Encoding
  + Upgrade


<br><br>
+ **串行事务处理时延**<br>
如果只对连接进行简单的管理，TCP 的性能时延可能会叠加起来。<br>
比如，假设有一个包含了 3 个嵌入图片的 Web 页面。浏览器需要发起 4 个 HTTP 事务来显示此页面： 1 个用于顶层的 HTML 页面，3 个用于嵌入的图片。如果每个事务都需要（串行地建立）一条新的连接，那么连接时延和慢启动时延就会叠加起来。<br>
即使同时加载多幅图片比一次加载一幅图片要慢，人们也会有同样的感觉！用户通常会认为多幅图片同时加载要快一些。下面介绍的四种方法可以提高 HTTP 的连接性能：
  + 并行连接
  > 通过多条 TCP 连接发起并发的 HTTP 请求
  + 持久连接
  > 重用 TCP 连接，以消除连接及关闭时延
  + 管道化连接
  > 通过共享的 TCP 连接发起并发的 HTTP 请求
  + 复用的连接
  > 交替传送请求和响应报文


## 并行连接
HTTP 允许客户端打开多条连接，并行地执行多个 HTTP 事务。
```
                                                      ----------
                                                      | 服务器1 |
                                                      ----------
                                                          |
                      ---------------                     |
  ---------           |    图片1     |  <------------------- 因特网                 ----------
  | 服务器 | ---->     |    图片2     |  <----------------------------------------  |        |
  ---------           |    图片3     |  <----------------------------------------  | 服务器2 |
                      |    图片4     |  <----------------------------------------  |        |
                      ---------------                                             -----------


  嵌入的组件不一定都在同一台 Web 服务器上，可以同多台服务器建立并行的连接
```

+ **并行连接可能会提高页面的加载速度**<br>
包含嵌入对象的组合页面如果能（通过并行连接）克服单条连接的空载时间和带宽限制，加载速度也会有所提高。时延可以重叠起来，而且如果单条连接没有充分利用客户端的因特网带宽，可以将未用带宽分配来装载其他对象。


<br><br>
+ **并行连接不一定更快**<br>
即使并行连接的速度可能会更快，但并不一定总是更快。客户端如果网络宽段不足，大部分时间都是在传送数据。在这种情况下，一个连接到速度较快服务器上的 HTTP 事务很容易耗尽所有可用的 Modem 宽带。如果并行加载多个对象
，每个对
象都去竞争这有限的宽带，这样带来的性能提升就会较小，甚至没有什么提升

<br><br>
+ **并行连接可能让人 “感觉” 更快一些**<br>
如果整个屏幕上有很多动作在进行，即使实际上秒表显示整个页面的下载时间更长，人们也会认为 web 页面加载得更快一些


## 持久连接
HTTP/1.1（以及 HTTP/1.0 的各种增强版本）允许 HTTP 设备在事务处理结束之后将 TCP 连接保持在打开状态，以便为未来的 HTTP 请求重用现存的连接。在事务处理结束之后仍然保持在打开状态的 TCP 连接被称为持久连接。重用已对目标服务器打开的空闲持久连接，就可以避开缓慢的连接建立阶段。而且，已经打开的连接还可以避免慢启动的拥塞适应阶段，以便更快速地进行数据的传输

+ **持久以及并行连接**<br>
并行连接可以提高复合页面的传输速度。但并行连接也有一些缺点：
  + 每个事务都会打开 / 关闭一条新的连接，会耗费时间和带宽
  + 由于 TCP 慢启动特效的存在，每条新连接的性能都会有所降低
  + 可打开的并行连接数量实际上是有限的

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
持久连接有一些比并行连接更好的地方。持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量。但是，管理持久连接时要特别小心，不然就会累积出大量的空闲连接，耗费本地以及远程客户端和服务器上的资源。持久连接与并行连接配合使用可能是最高效的方式。现在，很多 web 应用程序都会打开少量的并行连接，其中的每一个都是持久连接。持久连接有两种类型：
  + HTTP/1.O + “keep-alive” 连接
  + HTTP/1.1 “persistent” 连接


<br><br>
+ **HTTP/1.0 + keep-alive 连接**<br>
以下示图显示了 keep-alive 连接的一些性能优点，图中将在串行连接上实现 3 个 HTTP 事务的时间线与在一条持久连接上实现同样事务所需的时间线进行了比较。 由于去除了进行连接和关闭连接的开销，所以时间线有所缩减

```
   3 个事务（串行与持久连接）

  （a）串行连接
  -----------
  |         |             事务1                     事务2                       事务3
  |  服务器  |  -|=======================|========================|=========================|------->
  |         |                 -                       -                          -
  -----------               -   -   响应1            -   -  响应2               -    -  响应3
                          -       -               -        -                -         -
  -----------     请求1  -           -      请求2 -            -     请求3  -             -
  |         |         -               -       -                 -       -                 -
  |  客户端  |  -|-----|-----------------|-----|-------------------|-----|------------------|------->
  |         |    连接1                    连接2                      连接3                         time
  -----------


  （b）持久连接
  -----------
  |         |            事务1              事务2                事务3
  |  服务器  |  -|==================|===================|======================|------->
  |         |             -                  -                    -
  -----------           -   -   响应1       -   -  响应2         -    -  响应3
                      -       -          -        -           -         -
  ----------- 请求1  -           - 请求2 -            - 请求3 -             -
  |         |     -               - -                 - -                   -
  |  客户端  |   -|-----------------|-------------------|----------------------|------->
  |         |                                                                             time
  -----------


  由于去除了慢启动阶段，请求和响应时间可能也有缩减。这种性能收益在图中没有显示出来
```


<br><br>
+ **keep-alive 操作**<br>
keep-alive 已经不再使用了，而且在当前的 HTTP/1.1 规范中也没有对它的说明了。但浏览器和服务器对 keep-alive 握手的使用仍然相当广泛。<br>
实现 HTTP/1.0 keep-alive 连接的客户端可以通过包含 `Connection: Keep-Alive` 首部请求将一条连接保持在打开状态。如果服务器愿意为下一条请求将连接保持在打开状态，就在响应中包含相同的首部。如果响应中没有 `Connection: Keep-Alive` 首部，客户端就认为服务器不支持 keep-alive，会在发回响应报文之后关闭连接

```
                                      |-----------------------------|
                                      | HEAD /index.html HTTP/1.0   |
                                      | Host: www.joes-hardware.com |
                                      | Connection: Keep-Alive      |
                                      |-----------------------------|
                                                   ∧
                                                   |
  -----------                                     请求                                    ------------
  |         |  ----------------------------------------------------------------------->  |         |
  |  客户端  |                                                                            |  客户端  |
  |         |  <-----------------------------------------------------------------------  |         |
  -----------                                     响应                                   ------------
                                                   |
                                                   ∨
                                      |----------------------------|
                                      | HTTP/1.0 200 OK            |
                                      | Content-Type: text/html    |
                                      | Content-Length: Keep-Alive |
                                      | Connection: Keep-Alive     |
                                      | ...                        |
                                      |----------------------------|

  HTTP/1.0 keep-alive 事务首部的握手过程
```


<br><br>
+ **Keep-Alive 选项**<br>
keep-Alive 首部只是请求将连接保持在活跃状态。发出 keep-alive 请求之后，客户端和服务器并不一定会同意进行 keep-alive 会话。它们可以在任意时刻关闭空闲的 keep-alive 连接，并可随意限制 keep-alive 连接所处理事务的数量。可以用 Keep-Alive 通用首部中指定的、由逗号分隔的选项来调节 keep-alive 的行为
  + 参数 timeout 是在 Keep-Alive 响应首部发送的。它估计了服务器希望将连接保持在活跃状态的时间。这并不是一个承诺值
  + 参数 max 是在 Keep-Alive 响应首部发送的。它估计了服务器还希望为多少个事务保持此连接的活跃状态。这并不是一个承诺值
  + Keep-Alive 首部还可支持任意未经处理的属性，这些属性主要用于诊断和调试。语法为 name[=value]

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Keep-Alive 首部完全是可选的，但只有在提供 `Connection: Keep-Alive` 时才能使用它。这里有个 Keep-Alive 响应首部的例子，这个例子说明服务器最多还会为另外 5 个事务保持连接的打开状态，或者将打开状态保持到连接空闲了 2 分钟之后

```
  Connection: Keep-Alive
  Keep-Alive: max=5, timeout=120
```


<br><br>
+ **Keep-Alive 连接的限制和规则**<br>
在使用 Keep-Alive 连接时有一些限制和一些需要澄清的地方
  + 在 HTTP/1.0 中，keep-alive 并不是默认使用的。客户端必须发送一个 `Connection: Keep-Alive` 请求首部来激活 keep-alive 连接

  + `Connection: Keep-Alive` 首部必须随所有希望保持持久连接的报文一起发送。如果客户端没有发送 `Connection: Keep-Alive` 首部，服务器就会在那条请求之后关闭连接

  + 通过检测响应中是否包含 `Connection: Keep-Alive` 响应首部，客户端可以判断服务器是否会在发出响应之后关闭连接

  + 只有在无需检测到连接的关闭即可确定报文实体主体部分长度的情况下，才能将连接保持在打开状态 -- 也就是说实体的主体部分必须有正确的 `Content-Length`，有多部件媒体类型，或者用分块传输编码的方式进行了编码。在一条 `keep-alive` 信道中回送错误的 `Content-Length` 是很糟糕的事，这样的话，事务处理的另一端就无法精确地检测出一条报文的结束和另一条报文的开始了

  + 代理和网关必须执行 Connection 首部的规则。代理或网关必须在将报文转发出去或将其高速缓存之前，删除在 Connection 首部中命名的所有首部字段以及 Connection 首部自身

  + 严格来说，不应该与无法确定是否支持 Connection 首部的代理服务器建立 `keep-alive` 连接，以防止出现下面要介绍的哑代理问题。在实际应用中不是总能做到这一点的

  + 从技术上来讲，应该忽略所有来自 HTTP/1.0 设备的 Connection 首部字段（包括 `Connection: Keep-Alive`），因为它们可能是由比较老的代理服务器误转发的。但是有些客户端和浏览器还是会违反这条规则”

  + 除非重复发送请求会产生其他一些副作用，否则如果在客户端收到完整的响应之前连接就关闭了，客户端就一定要做好重试请求的准备


## Keep-Alive 和哑代理
keep-alive 和哑代理会有一些比较微妙的问题。web 客户端的 `Connection: Keep-Alive` 首部应该只会对这条离开客户端的 TCP 链路产生影响。这就是将其称作 “连接” 首部的原因。如果客户端正在与一台 web 服务器对话，客户端可以发送一个 `Connection: Keep-Alive` 首部来告知服务器它希望保持连接的活跃状态。如果服务器支持 keep-alive，就回送一个 `Connection: Keep-Alive` 首部，否则就不回送

+ **Connection 首部和盲中继**<br>
问题出在代理上 ---- 尤其是那些不理解 Connection 首部，而且不知道在沿着转发链路将其发送出去之前，应该将该首部删除的代理。很多老的或者简单的代理都是**盲中继**，他们只是将字节从一个连接转发到另一个连接中去，不对 Connection 首部进行特殊的处理，假如有一个 web 客户端正通过一个作为盲中继使用的哑代理与 web 服务器进行对话，如以下所示：

```
                                                                                              （b）服务器认为对方请求保持连接活跃，
                                                                                                因此处理完连接后不会将其关闭
                                                                                                        ∧
                                                                                                        |
  -----------  （a）Connection: Keep-Alive    --------------    （b）Connection: Keep-Alive      -----------
  |         |   ------------------------->    |           |     -------------------------->     |         |
  |  客户端  |                                 |   哑代理   |                                     |  服务器  |
  |         |   <-------------------------    |           |     <--------------------------     |         |
  -----------   (d) Connection: Keep-Alive    -------------    （c）Connection: Keep-Alive      ------------
      |                                          ∧    ∧                                                 |
      |                                          |    |                                                 |
      --------------------------------------------     ---------------------------------------------------
              （e）由于代理不会对其进行处理，                                （c）代理会忽略连接上所有新的请求，
                所以客户端在 keep-alive                                  等待连接关闭
                连接上发起的第二条请求会被挂起


  keep-alive 无法与不支持 Connection 首部的代理进行互操作
```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
上面示图发送的情况如下：
  1. 在 (a) 中，web 客户端向代理发送了一条报文，其中包含了 `Connection: Keep-Alive` 首部，如果可能的话请求建立一条 keep-alive 连接。客户端等待响应，以确定对方是否认可它对 keep-alive 信道的请求

  2. 哑代理收到了这条 HTTP 请求，但它并不理解 Connection 首部。代理不知道 keep-alive 是什么意思，因此只是沿着转发链路将报文一字不漏地发送给服务器。但 Connection 首部是个逐跳首部，只是用与单条传输链路，不应该沿着传输链路向下传输，接下来会有一些很糟糕的事情发送

  3. 在 (b) 中，经过中继的 HTTP 请求抵达了 web 服务器。当 web 服务器收到经过代理转发的 `Connection: Keep-Alive` 首部时，会误以为代理（对服务器来说，这个代理看起来就和所有其他客户端一样）希望进行 keep-alive 对话！对 web 服务器来说这没什么问题——它同意进行 keep-alive 对话，并在 (c) 中回送了一个 `Connection: Keep-Alive` 响应首部。所以，此时 web 服务器认为它在与代理进行 keep-alive 对话，会遵循 keep-alive 的规则。但代理却对 keep-alive 一无所知。不妙（也就是服务器与亚代理在进行 keep-alive，有点逗）

  4. 在 (d) 中，哑代理将 web 服务器的响应报文回送给客户端，并将来自 web 服务器的 `Connection: Keep-Alive` 首部一起传送过去，客户端看到这个首部，就会认为代理同意进行 keep-alive 对话。所以，此时客户端和服务器都认为他们在进行 keep-alive 对话，但是与他们进行对话的代理却对 keep-alive 一无所知。（服务器和客户端让一个傻子传话，而且他俩还都不知道传话的那个是傻子）

  5. 由于代理对 keep-alive 一无所知，所以会将收到的所有数据都回送给客户端，然后等待源端服务器关闭连接。但源端服务器会认为代理意见显示地请求它将连接保持在打开状态，所以不会去关闭连接。这样，代理就会挂在那里等待连接的关闭

  6. 客户端在（d）中收到了回送的响应报文时，会立即转向下一条请求，在 keep-alive 连接上向代理发送另一条请求，在 keep-alive 连接上向代理发送另一条请求（参见 e）。而代理并不认为同一条连接上会有其他请求到来，请求被忽略，浏览器就在这里转圈，不会有任何进展了

  7. 这种错误的通信方式会使浏览器一直处于挂起状态，直到客户端或服务器将连接超时，并将其关闭为止


<br><br>
+ **代理和逐跳首部**<br>
为避免此类代理通信问题的发生，现代的代理都绝不能转发 Connection 首部和所有名字出现在 Connection 值中的首部。因此，如果一个代理收到了一个 `Connection: Keep-Alive` 首部，是不应该转发 Connection 首部，或所有名为 Keep-Alive 的首部的。<br>
另外，还有几个不能作为 Connection 首部值列出，也不能被代理转发或作为缓存响应使用的首部。其中包括 Proxy-Authenticate、Proxy-Connection、Transfer-Encoding 和 Upgrade


<br><br>
+ **插入Proxy-Connection**<br>