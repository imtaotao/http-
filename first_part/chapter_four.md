# 4.连接管理
本章内容主要介绍如下：

- HTTP 是如何使用 TCP 连接的
- TCP 连接的时延、瓶颈以及存在的障碍
- HTTP 的优化，包括并行连接、keep-alive（持久连接）和管道化连接
- 管理连接时应该以及不应该做的事情

## TCP 连接
例如：`http://www.joes-hardware.com:80/power-tools.html`<br>
浏览器收到一个 URL 会执行以下步骤：<br>

> 浏览器解析出主机名（www.joes-hardware.com）
> 浏览器查询这个主机名的 IP 地址（DNS --> 202.43.78.3)
> 浏览器获得端口号（80）
> 浏览器发送到 202.43.78 端口 80 的连接
> 浏览器向服务器发送一条 HTTP GET 报文
> 浏览器从服务器读取 HTTP 响应报文
> 浏览器关闭连接

+ **TCP 流是分段的、由 IP 分组传送**<br>
TCP 为 HTTP 提供了一条可靠的比特传输管道。从 TCP 连接一端填入的字节会从另一端以原有的顺序、正确地传送出来。TCP 的数据是通过名为 IP 分组（或 IP 数据报）的小数据块来发送的。这样的话，HTTP 就是 `HTTP over TCP over IP` 这个 “协议栈” 中的最顶层了。其安全版本 HTTPS 就是在 HTTP 和 TCP 之间插入了一个（称为 TLS 或 SSL 的）密码加密层。<br>
HTTP 要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的 TCP 连接按序传输。TCP 收到数据流之后，会将数据流砍成被称作段的小数据块，并将段封装在 IP 分组中，通过因特网进行传输。<br>
每个 TCP 段都是由 IP 分组承载，从一个 IP 地址发送到另一个 IP 地址的，每个 IP 分组中都包括：
  1. 一个 IP 分组首部（通常为 20 字节）
  2. 一个 TCP 段首部（通常为 20 字节）
  3. 一个 TCP 数据块（0 个或多个字节）

<br><br>
+ **保持 TCP 连接的持续不断地运行**<br>
在任意时刻计算机都有可以几条 TCP 连接处于打开状态。TCP 连接是通过 4 个值来识别的：
```
  <源 IP 地址、源端端口号、目的 IP 地址、目的端口号>
```
&nbsp;&nbsp;&nbsp;&nbsp;这四个值一起唯一地定义了一条连接。两条不同的 TCP 连接不能拥有 4 个完全相同的地址组件值

<br><br>
+ **用 TCP 套接字编程**<br>
操作系统提供了一些操作其 TCP 连接的工具。套接字 API 允许用户创建 TCP 的端点数据结构，将这些端点与远程服务器的 TCP 端点进行连接，并对数据流进行写入。以下为常见的套接字接口函数：

| 套接字 API 调用                   | 描述                     |
|------------------------------|------------------------|
| s = socket(<parameters>)     | 创建一个新的、未命名、未关联的套接字     |
| bind(s, <local IP:port>)     | 向套接字赋一个本地端口号和接口        |
| connect(s, <remote IP:port>) | 创建一条连接本地套接字与远程主机及端口的连接 |
| listen(s, ...)               | 标识一个本地套接字，使其可以合法接受连接   |
| s2 = accept(s)               | 等待某人建立一条到本地端口的连接       |
| n = read(s, buffer, n)       | 尝试从套接字向缓冲区读取 n 个字节     |
| n = write(s, buffer, n)      | 尝试从缓冲区中向套接字写入 n 个字节    |
| close(s)                     | 完全关闭 TCP 连接            |
| shutdown(s, <side>)          | 值关闭 TCP 连接的输入或输出端      |
| getsockopt(s, ...)           | 读取某个内部套接字配置选项的值        |
| setsockopt(s, ...)           | 修改某个内部套接字配置选项的值        |

```
      ---------                                  ---------
      | 客户端 |                                  | 服务器 |
      ---------                                  ---------

                                                （S1）创建新的套接字（socket）
                                                （S2) 将套接字绑定到端口 80 上去（bind）
                                                （S3）允许套接字进行连接（listen）
                                                （S4）等待连接（accept）
                                                           |
      （C1）获取 IP 地址和端口号                              |
      （C2）创建新的套接字（socket）。                         |
      （C3）连接到服务器 IP:port 上去（connect）  -----        |
         |                                        |        |
         |                                        V        |
         |     -------------------------------- （S5）通知应用程序有连接到来
         |     |                                （S6）开始读取请求（read）
         |     v                                           |
      （C4）连接成功                                         |
      （C5）发送 HTTP 请求（write） -----------------         |
      （C6）等待 HTTP 响应（read）。                |         |
         |                                        V        |
         |                                      （S7）处理 HTTP 请求报文
         |    --------------------------------- （S8）回送 HTTP 响应（write）
         |    |                                 （S9）关闭连接（close）
         |    V
      （C7）处理 HTTP 响应
      （C8）关闭连接（close）
```


## 对 TCP 性能考虑
HTTP 紧挨着 TCP，位于其上层，所以 HTTP 事务的性能在很大程度上取决于底层 TCP 通道的性能

+ **HTTP 事物的时延**<br>
HTTP 事务的时延有以下几种主要原因：
  1. 客户端首先需要根据 URL 确定 web 服务器的 IP 地址和端口号。如果最近没有对 URL 中的主机名进行访问，需要通过 DNS 解析，而 DNS 解析可能花费数十秒时间（大多数浏览器有 DNS 缓存）

  2. 接下来客户端会向服务器发送一条 TCP 连接请求，并等待服务器回送一个请求接受应答。每条新的 TCP 连接都会有连接建立时延。这个值最多只有一两秒种。但是如果有数百个 HTTP 事务，这个值会快速叠加上去

  3. 一旦连接建立起来了，客户端会通过建立新的 TCP 管道来发送 HTTP 请求。数据到达，服务器读取报文，处理请求。因特网传输报文等都需要时间

  4. 然后，服务器回送 HTTP 响应，也需要花费时间

<br><br>
+ **性能聚焦区域**<br>
一些常见的 TCP 相关时延，包括：
  + TCP 连接建立握手
  + TCP 慢启动拥塞控制
  + 数据聚焦的 Nagle 算法
  + 捎带确认的 TCP 延迟确认算法
  + TIME_WAIT 时延和端口耗尽

<br><br>
+ **TCP 连接的握手时延（经典的 tcp 三次握手）**<br>
TCP 连接握手需要经过以下几个步骤：
  1. 请求新的 TCP 连接时，客户端要向服务器发送一个小的 TCP 分组（通常是 40 ~ 60 个字节）。这个分组设置了一个特殊的 SYN 标记，说明这是一个请求

  2. 如果服务器接受了请求，就会对一些连接参数进行计算，并向客户端回送一个 TCP 分组，这个分组中的 SYN 和 ACK 标记都被置位，说明请求已被接受

  3. 最后，客户端向服务器回送一条确认消息，通知它连接已成功建立。现代的 TCP 栈都允许客户端在这个确认分组中发送数据

```
  ---------
  | 服务器 |  -------------|--------------------------------------------------------------->
  ---------          (a) SYN  _             (c) ACK
                      -        -                GET/HTTP...
                    —            -          -             -
                  —                -      -                 -
  ---------     —             (b) SYN + ACK                    (d) HTTP/1.1 304 Not modified
  | 客户端 |  ---|---------------------|-------------------------|--------------------------->
  ---------    连接   连接握手时延                 数据传输                                   time


  常 HTTP 事务都不会交换太多数据，此时，SYN/SYN+ACK 握手会产生一个可测量的时延
  小的 HTTP 事务可能会在 TCP 连接上花费 50%，甚至更多
```
<br><br>
+ **延迟确认**<br>
由于因特网自身无法确保可靠的分组传输，所以 TCP 实现了自己的确认机制。每个 TCP 段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的时段，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者就任务数据已经被破坏损毁，并重发数据。<br>
由于确认报文很小，所以 TCP 允许在发往相同反向的输出数据分组中对其进行 “捎带”。TCP 将返回的确认信息与输出的数据分组结合在一起，可以更有效地利用网络（利用空间换因特网传输时间，但这个只针对大块数据传输的情况下）。**为了增加确认报文找到同向传输数据分组的可能性，很多 TCP 栈实现了一种 “延迟确认” 算法**。延迟确认算法会在一个特定的窗口时间（通常是 100 ～ 200 毫秒）内将输出确认存放在缓冲区中，以寻找能够捎带它的输出数据分组。如果那个时间段没有输出数据分组，就将确认信息放在单独的分组中传送。<br>
但是 HTTP 具有双峰特征的请求（请求、响应）降低了捎带信息的可能（有可能没有要传输的数据，那么确认就必须在延时之后独自发送）。延迟确认算法会引入相当大的时延。根据所使用操作系统的不同，可以调整或禁止延迟确认算法

<br><br>
+ **TCP 慢启动**<br>
TCP 数据传输的性能还取决于 TCP 连接的使用期（age）。TCP 连接会随着时间进行自我 “调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐被称为 TCP 慢启动，用于防止因特网的突然过载和拥塞。<br>
TCP 慢启动限制了一个 TCP 端点在任意时刻可以传输的分组数。简单来说，每成功接收一个分组，发送端就有了发送另外两个分组的权限。**如果某个 HTTP 事务有大量数据要发送，是不能一次将所有分组都发送出去的**。必须发送一个分组，等待确认；然后可以发送两个分组，每个分组都必须被确认，这样就可以发送四个分组了，以此类推。这种方式被称为 “打开拥塞窗口”。所以**新连接的传输速度会比已经交换过一定量数据的、“已调谐” 连接慢一些”**

<br><br>
+ **Nagle 算法与 TCP_NODELAY**<br>
TCP 有一个数据流接口，应用程序可以通过它将任意尺寸的数据放入 TCP 栈中，所以如果 TCP 发送大量包含少量数据的分组，网络性能会严重下降。<br>
“Nagle 算法试图在发送一个分组之前，将大量 TCP 数据绑定在一起，以提高网络效率。RFC 896“IP/TCP 互连网络中的拥塞控制”对此算法进行了描述。Nagle 算法鼓励发送全尺寸（LAN 上最大尺寸的分组大约是 1500 字节，在因特网上是几百字节）的段。只有当所有其他分组都被确认之后，Nagle 算法才允许发送非全尺寸的分组。如果其他分组仍然在传输过程中，就将那部分数据缓存起来。只有当挂起分组被确认（延迟确认），或者缓存中积累了足够发送一个全尺寸分组的数据时，才会将缓存的数据发送出去。<br>
Nagle 算法会引发几种 HTTP 性能问题：

  + 小的 HTTP 报文可能无法填满一个分组，可能会因为等待那些永远不会到来的额外数据而产生时延
  + Nagle 算法与延迟确认之间的交互存在问题 —— Nagle 算法会阻止数据的发送，直到有确认分组抵达为止，但确认分组自身会被延迟确认算法延迟 100 ～ 200 毫秒

&nbsp;&nbsp;&nbsp;&nbsp;HTTP 应用程序常常会在自己的栈中设置参数 TCP_NODELAY，禁用 Nagle 算法，提高性能

<br><br>
+ **TIME_WAIT 累积与端口耗尽**<br>
当某个 TCP 端点关闭 TCP 连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的 IP 地址和端口号。这类信息只会维持一小段时间，通常是所估计的最大分段使用期的两倍（称为 2MSL，通常为 2 分钟，有的会改为更小的值）左右，以确保在这段时间内不会创建具有相同地址和端口号的新连接。实际上，这个算法可以防止在两分钟内创建、关闭并重新创建两个具有相同 IP 地址和端口号的连接。<br>
在只有一台或几台用来产生流量的计算机连接到某系统中时，会限制了连接到服务器的客户端 IP 地址数，这样就限制了可以用的连接值组合

```
  <source-IP-address, source-port, destination-IP-address, destination-port>


  其中的 3 个都是固定的——只有源端口号可以随意改变：
  <client-IP, source-port, server-IP, 80>
```

&nbsp;&nbsp;&nbsp;&nbsp;客户端每次连接到服务器上去时，都会获得一个新的源端口，以实现连接的唯一性。但由于可用源端口的数量有限（比如，60 000 个），而且在 2MSL 秒（比如，120 秒）内连接是无法重用的，连接率就被限制在了 60 000/120=500 次 / 秒。如果再不断进行优化，并且服务器的连接率不高于 500 次 / 秒，就可确保不会遇到 TIME_WAIT 端口耗尽问题

<br><br>
## HTTP 连接的处理
+ **常被误解的 Connection 首部**<br>
HTTP 的 Connection 首部字段中有一个由逗号分隔的连接标签列表，这些标签为此连接指定了一些不会传播到其他连接中去的选项。比如，可以用 Connection:close 来说明发送完下一条报文之后必须关闭的连接。Connection 首部可以承载 3 种不同类型的标签：
  + HTTP 首部字段名，列出了只与此连接有关的首部
  + 任意标签值，用于描述此连接的非标准选项
  + 值 close，说明操作完成之后需关闭这条持久连接

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
如果连接标签中包含了一个 HTTP 首部字段的名称，那么这个首部字段就包含了与一些连接有关的信息，不能将其转发出去。在将报文转发出去之前，必须删除 Connection 首部列出的所有首部字段。由于 Connection 首部可以防止无意中对本地首部的转发，因此将逐跳首部名放入 Connection 首部被称为 “对首部的保护”。还会有一些一定不能被代理转发的逐跳首部（有关 Connection 首部详情见附录 C）。其中包括：

  + Prxoy-Authenticate
  + Proxy-Connection
  + Transfer-Encoding
  + Upgrade

<br><br><br>
+ **串行事务处理时延**<br>
