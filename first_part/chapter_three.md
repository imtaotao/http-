# HTTP 报文
本章内容较多，主要介绍如下：

- 报文是如何流动的
- HTTP 报文的三个组成部分（起始行、首部和实体的主体部分）
- 请求和响应报文之间的区别
- 请求报文支持的各种方法
- 和响应报文一起返回的各种状态码
- 各种各样的 HTTP 首部都是用来做什么的

### 报文流
报文在客户端、服务器和代理之间流动。术语“流入”、“流出”、“上游”以及“下游”都是用来描述报文方向的。

+ 报文流入源服务器，工作完成之后，会流回用户的 Agent 代理中，HTTP 报文会像河水一样流动，不管是请求还是响应报文，都会向下游流动，所有报文的发送者都在接收者的上游。

### 报文的组成
HTTP 报文是简单的格式化数据块。每条报文由三部分组成，对报文进行描述的**起始行**、包含属性的**首部**快、以及可选的、包含数据的**主体**部分

+ 起始行和首部是由行分割的 ASCII 文本。每行都以一个由两个字符组成的终止符组成的行终止序列作为结束，其中包括一个回车符和一个换行符。这个行终止序列可以写作 CRLF，但是有些 HTTP 应用程序并不总是既发送回车符，又发送换行符。

### 报文的语法
所有的 HTTP 报文都可以分为两类：**请求报文** 和 **响应报文**

+ 请求报文格式：
```xml
  <method><request-URL><version>
  <headers>

  <entity-body>
```
<br>

+ 响应报文格式：
```xml
  <version><status><reason-phrase>
  <headers>

  <entity-body>
```

**对各个部分的简要概述**

+ 方法（method）
> 客户端希望服务器对资源执行的动作。是一个单独的单词，比如 GET、 HEAD、 POST

+ 请求 URL (request-URL)
> 命名了所请求资源，或者 URL 路径组件的完整 URL，与服务器对话，只要 URL 的路径组件是资源的绝对路径，通常不会有问题。服务器可以假定自己是 URL 的主机/端口。详见[第二章](./chapter_two.md)

+ 版本（version）
> 报文所使用的 HTTP 版本，格式如下：
```xml
  HTTP/<major>.<minor>
```

+ 状态码（status-code）
> 这个三位数字描述了请求过程中所发生的情况，每个状态码的第一个数字用于描述状态的一般类别（“成功”、“出错”等，也就是 1xx、2xx、3xx、4xx、5xx）

+ 原因短句（reason-phrase）
> 原因短句只对人类有意义。因此，比如说，尽管响应行 `HTTP/1.0 200 NOT OK` 和 `HTTP/1.0 200 OK` 中的原因断句不同，但都会被当作成功指示处理

+ 首部（header）
> 可以有零个或多个首部，首部由一个名字，后面跟着一个 `:`，然后是一个可选的空格，接着是一个值，最后是一个 CRLF，首部是由一个空行（CRLF）结束的。有些 HTTP 版本，比如 HTTP/1.1，要求有效的请求或响应报文中必须包含特定的首部

+ 实体的主体部分（entity-body）
> 实体的主体部分包含一个由任意数据组成的数据块，并不是所有的报文都包含实体的主体部分，有时，报文只是以一个 CRLF 结束


### 起始行
以下为假想的请求和响应报文

```
                (a) 请求报文                                  (b) 响应报文                 
  ----------------------------------            ----------------------------------- 
  | GET /testhi-there.txt HTTP/1.1 |  起始行     | HTTP/1.0 200 OK                 |
  |--------------------------------|            |---------------------------------|
  | Accept: text/*                 |            | Content-type: text/plain        |
  | Host: www.joes-hardware.com    |   首部      | Content-length: 19              |
  |--------------------------------|            |---------------------------------|
                                                |                                 |
                                                | Hi! I'm a message!              |
                                       主体      |---------------------------------|

```

+ 请求行的起始行以方法作为开始，用来告知服务器要做什么，有些方法中包含了主体，有些不包含，以下是常用的 HTTP 方法

| 方法      | 描述                        | 是否包含主体 |
|---------|---------------------------|--------|
| GET     | 从服务器获取一份稳定                | 否      |
| HEAD    | 只从服务器获取文档的首部              | 否      |
| POST    | 向服务器发送需要处理的数据             | 是      |
| PUT     | 将请求的主体部分存储到服务器上           | 是      |
| TRACE   | 对可能经过代理服务器传送到服务器上去的报文进行追踪 | 否      |
| OPTIONS | 决定可以在服务器上执行哪些方法           | 否      |
| DELETE  | 从服务器上删除一份文档               | 否      |

+ 状态码的分类

| 整体范围      | 已定义范围     | 分类    |
|-----------|-----------|-------|
| 100 ~ 199 | 100 ~ 101 | 信息提示  |
| 200 ~ 299 | 200 ~ 206 | 成功    |
| 300 ~ 399 | 300 ~ 305 | 重定向   |
| 400 ~ 499 | 400 ~ 415 | 客户端错误 |
| 500 ~ 599 | 500 ~ 505 | 服务器错误 |

### 首部
HTTP 首部字符向请求和响应报文中添加了一些附加信息。本质上来说，它们只是一些名 `key/value` 对的列表。HTTP 规范定义了几种首部，但是应用程序也可以随意发明自己所用的首部，HTTP 首部可以分为以下几类

+ 通用首部
> 既可以出现在请求报文中，也可以出现在响应报文中

+ 请求首部
> 提供更多有关请求的信息

+ 响应首部
> 提供更多有关响应的信息

+ 实体首部
> 描述主体的长度和内容，或者资源本身

+ 扩展首部
> 规范中没有定义的新首部

每个 HTTP 首部都有一种简单的语法：
```
  名字后面跟着冒号（:），然后跟上可以选的空格，再跟上字段值，最后是一个 CRLF
```

**首部延续行**：将长的首部行分为多行可以提高可读性，多出来的每行前面至少要有一个空格或者制表符。例如：
```
  Server: Test Server
    Version 1.0
```

### 实体的主体部分

HTTP 报文的第三部分是可选的实体主体部分。实体的主体是 HTTP 报文的负荷。就是 HTTP 要传输的内容。HTTP 报文可以承载很多类型的数字类型：图片、视频、HTML 文档、软件应用程序、信用卡事务、电子邮件等

### 方法（详细描述）

+ **安全方法**<br>
HTTP 定义了一组被称为安全方法的方法。GET 和 HEAD 方法都被认为是安全的，这以为这 GET 和 HEAD 方法的 HTTP 请求不会产生什么动作（也就是不会对服务器产生一些行为，比如服务存储、删除、更改资源等，那 POST 之类的方法就会产生一些行为）<br>
安全方法并不一定是什么动作都不执行（实际上这由 web 开发者决定）。使用安全方法的目的就是当使用可能引发某一动作的不安全方法时，允许 HTTP 应用程序开发者通知用户，比如用不安全的方法发起请求，会在服务器上产生一些事件（你的信用卡支付费用）

+ **GET**<br>
GET 是最常用的方法。通常用于请求服务器发送某个资源。HTTP/1.1 要求服务器实现此方法
```
    请求报文
  |----------------------------------------|
  | GET /seasonal/index-fall.html HTTP/1.1 |
  | Host: www.joes-hardware.com            |
  | Accept: *                              |
  |----------------------------------------|

    响应报文
  |---------------------------------------------|
  | HTTP/1.1 200 OK                             |
  | Content-Type: text/html                     |
  | Content-Length: 617                         |
  |                                             |
  | <HTML>                                      |
  | <HEAD><TITLE> Joeos Special Offers </TITLE> |
  | ...                                         |
  |---------------------------------------------|
```

+ **HEAD**<br>
HEAD 方法与 GET 方法行为类似，但服务器在响应中只返回首部，不会返回实体的主体部分，这样就允许客户端为获取实际资源的情况下，对资源的首部进行检查，HTTP/1.1 规范，必须实现 HEAD 方法。使用 HEAD，可以：
  1) 在不获取资源的情况下了解资源情况（比如判断其类型）
  2) 通过查看响应首部的状态码，看看某个对象是否存在
  3) 通过查看首部，测试资源是否被修改了

```
    请求报文
  |-----------------------------------------|
  | HEAD /seasonal/index-fall.html HTTP/1.1 |
  | Host: www.joes-hardware.com             |
  | Accept: *                               |
  |-----------------------------------------|

    响应报文（没有实体的主体部分）
  |-----------------------------------------|
  | HTTP/1.1 200 OK                         |
  | Content-Type: text/html                 |
  | Content-Length: 617                     |
  |-----------------------------------------|
```

+ **PUT**<br>
与 GET 从服务器读取文档相反，PUT 方法会向服务器写入文档。有些发布系统允许用户创建 web 页面，并用 PUT 直接将其安装到 web 服务器上去。PUT 方法的语义就是让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，如果那个 URL 已经存在，就用这个主体替代它。<br>
因为 PUT 方法允许用户对内容进行修改，所以很多 web 服务器都要求在执行 PUT 之前，用密码登录。详情见[第十二章](../three_part/chapter_twelve.md)

```
    请求报文
  |----------------------------------------|
  | PUT /product-list.txt HTTP/1.1         |
  | Host: www.joes-hardware.com            |
  | Content-type: text/plain               |
  | Content-length: 34                     |
  |                                        |
  | Updated product list coming soon!      |
  |----------------------------------------|

    响应报文（服务器更新/创建资源/product-list.txt，并将其写入自己的磁盘）
  |---------------------------------------------------------|
  | HTTP/1.1 201 Created                                    |
  | Location: http://www.joes-hardware.com/product-list.txt |
  | Content-Type: text/plain                                |
  | Content-Length: 47                                      |
  |                                                         |
  | http://www.joes-hardware.com/product-list.txt           |
  |---------------------------------------------------------|
```

+ **POST**<br>
POST 方法起初是用来向服务器输入数据的（POST 用于向服务器发送数据，PUT 用于向服务器上的资源`例如文件`中存储数据），实际上，通常会用它来支持 HTML 中的表单（但是我感觉现在 xhr 用的多些，表单都不怎么用了，虽然用表单没有跨域，但是很难做到无刷新）。

+ **TRACE**<br>
客户端发起一个请求时，这个请求可能会穿过防火墙、代理、网关或者其他一些应用程序。每个中间节点都可能会修改原始的 HTTP 请求。TRACE 方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子<br>
TRACE 请求会在目的地服务器端发起一个 “环回” 诊断。行程最后一站的服务器会弹回一条 TRACE 响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看所有 HTTP 中间应用程序的请求/响应链上，原始报文是否、以及、如何被毁坏或修改

```
    请求报文          
  |----------------------------------|        |----------------------------------|
  | TRACE /product-list.txt HTTP/1.1 |  代理   | TRACE /product-list.txt HTTP/1.1 | 
  | Accept: *                        | -----> | Host: www.joes-hardware.com      |
  | Host: www.joes-hardware.com      |        | Accept: *                        |
  |----------------------------------|        | Via: 1.1 proxy3.company.com      |
                                              |----------------------------------| 
                                                              |
                                                              |
                                                              v
                                                响应报文
  |----------------------------------|        |----------------------------------|
  | HTTP/1.1 200 OK                  |        | HTTP/1.1 200 OK                  |
  | Content-Type: text/plain         |        | Content-Type: text/plain         |
  | Content-Length: 96               |        | Content-Length: 96               |
  | Via: 1.1 proxy3.company.com      |  代理   |                                  |
  |                                  | <----- | TRACE /product-list.txt HTTP/1.1 |
  | TRACE /product-list.txt HTTP/1.1 |        | Host: www.joes-hardware.com      |
  | Host: www.joes-hardware.com      |        | Accept: *                        |
  | Accept: *                        |        | Via: 1.1 proxy3.company.com      |
  | Via: 1.1 proxy3.company.com      |        |----------------------------------|
  |----------------------------------|
```
TRACE 方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链，也可以用来查看代理和其他应用程序对用户请求所产生的效果<br>
但是它也有缺点，它假定中间应用程序对各种不同类型请求（GET、POST、HEAD等）的处理是相同的。比如代理可能会将 POST 请求直接发送给服务器，将 GET 请求发送给另外一个 HTTP 应用程序（比如 web 缓存），TRACE 并不提供区分这些方法的机制。通常，中间应用程序会自行决定对 TRACE 请求的处理方式<br><br>

TRACE 请求中不能带有实例的主体部分。TRACE 响应的实体主体部分包含了响应服务器收到的请求的精确副本

+ **OPTIONS**<br>
