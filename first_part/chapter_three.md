# 3.HTTP 报文
本章内容较多，也很重要，主要介绍如下：

- 报文是如何流动的
- HTTP 报文的三个组成部分（起始行、首部和实体的主体部分）
- 请求和响应报文之间的区别
- 请求报文支持的各种方法
- 和响应报文一起返回的各种状态码
- 各种各样的 HTTP 首部都是用来做什么的

### 报文流
报文在客户端、服务器和代理之间流动。术语“流入”、“流出”、“上游”以及“下游”都是用来描述报文方向的。

+ 报文流入源服务器，工作完成之后，会流回用户的 Agent 代理中，HTTP 报文会像河水一样流动，不管是请求还是响应报文，都会向下游流动，所有报文的发送者都在接收者的上游。

### 报文的组成
HTTP 报文是简单的格式化数据块。每条报文由三部分组成，对报文进行描述的**起始行**、包含属性的**首部**快、以及可选的、包含数据的**主体**部分

+ 起始行和首部是由行分割的 ASCII 文本。每行都以一个由两个字符组成的终止符组成的行终止序列作为结束，其中包括一个回车符和一个换行符。这个行终止序列可以写作 CRLF，但是有些 HTTP 应用程序并不总是既发送回车符，又发送换行符。

### 报文的语法
所有的 HTTP 报文都可以分为两类：**请求报文** 和 **响应报文**

+ 请求报文格式：
```xml
  <method><request-URL><version>
  <headers>

  <entity-body>
```
<br>

+ 响应报文格式：
```xml
  <version><status><reason-phrase>
  <headers>

  <entity-body>
```

**对各个部分的简要概述**

+ 方法（method）
> 客户端希望服务器对资源执行的动作。是一个单独的单词，比如 GET、 HEAD、 POST

+ 请求 URL (request-URL)
> 命名了所请求资源，或者 URL 路径组件的完整 URL，与服务器对话，只要 URL 的路径组件是资源的绝对路径，通常不会有问题。服务器可以假定自己是 URL 的主机/端口。详见[第二章](./chapter_two.md)

+ 版本（version）
> 报文所使用的 HTTP 版本，格式如下：
```xml
  HTTP/<major>.<minor>
```

+ 状态码（status-code）
> 这个三位数字描述了请求过程中所发生的情况，每个状态码的第一个数字用于描述状态的一般类别（“成功”、“出错”等，也就是 1xx、2xx、3xx、4xx、5xx）

+ 原因短句（reason-phrase）
> 原因短句只对人类有意义。因此，比如说，尽管响应行 `HTTP/1.0 200 NOT OK` 和 `HTTP/1.0 200 OK` 中的原因断句不同，但都会被当作成功指示处理

+ 首部（header）
> 可以有零个或多个首部，首部由一个名字，后面跟着一个 `:`，然后是一个可选的空格，接着是一个值，最后是一个 CRLF，首部是由一个空行（CRLF）结束的。有些 HTTP 版本，比如 HTTP/1.1，要求有效的请求或响应报文中必须包含特定的首部

+ 实体的主体部分（entity-body）
> 实体的主体部分包含一个由任意数据组成的数据块，并不是所有的报文都包含实体的主体部分，有时，报文只是以一个 CRLF 结束


### 起始行
以下为假想的请求和响应报文

```
                (a) 请求报文                                  (b) 响应报文
  ----------------------------------            -----------------------------------
  | GET /testhi-there.txt HTTP/1.1 |  起始行     | HTTP/1.0 200 OK                 |
  |--------------------------------|            |---------------------------------|
  | Accept: text/*                 |            | Content-type: text/plain        |
  | Host: www.joes-hardware.com    |   首部      | Content-Length: 19              |
  |--------------------------------|            |---------------------------------|
                                                |                                 |
                                                | Hi! I'm a message!              |
                                       主体      |---------------------------------|

```

+ 请求行的起始行以方法作为开始，用来告知服务器要做什么，有些方法中包含了主体，有些不包含，以下是常用的 HTTP 方法

| 方法      | 描述                        | 是否包含主体 |
|---------|---------------------------|--------|
| GET     | 从服务器获取一份稳定                | 否      |
| HEAD    | 只从服务器获取文档的首部              | 否      |
| POST    | 向服务器发送需要处理的数据             | 是      |
| PUT     | 将请求的主体部分存储到服务器上           | 是      |
| TRACE   | 对可能经过代理服务器传送到服务器上去的报文进行追踪 | 否      |
| OPTIONS | 决定可以在服务器上执行哪些方法           | 否      |
| DELETE  | 从服务器上删除一份文档               | 否      |

+ 状态码的分类

| 整体范围      | 已定义范围     | 分类    |
|-----------|-----------|-------|
| 100 ~ 199 | 100 ~ 101 | 信息提示  |
| 200 ~ 299 | 200 ~ 206 | 成功    |
| 300 ~ 399 | 300 ~ 305 | 重定向   |
| 400 ~ 499 | 400 ~ 415 | 客户端错误 |
| 500 ~ 599 | 500 ~ 505 | 服务器错误 |

### 首部
HTTP 首部字符向请求和响应报文中添加了一些附加信息。本质上来说，它们只是一些名 `key/value` 对的列表。HTTP 规范定义了几种首部，但是应用程序也可以随意发明自己所用的首部，HTTP 首部可以分为以下几类

+ 通用首部
> 既可以出现在请求报文中，也可以出现在响应报文中

+ 请求首部
> 提供更多有关请求的信息

+ 响应首部
> 提供更多有关响应的信息

+ 实体首部
> 描述主体的长度和内容，或者资源本身

+ 扩展首部
> 规范中没有定义的新首部

每个 HTTP 首部都有一种简单的语法：
```
  名字后面跟着冒号（:），然后跟上可以选的空格，再跟上字段值，最后是一个 CRLF
```

**首部延续行**：将长的首部行分为多行可以提高可读性，多出来的每行前面至少要有一个空格或者制表符。例如：
```
  Server: Test Server
    Version 1.0
```

### 实体的主体部分

HTTP 报文的第三部分是可选的实体主体部分。实体的主体是 HTTP 报文的负荷。就是 HTTP 要传输的内容。HTTP 报文可以承载很多类型的数字类型：图片、视频、HTML 文档、软件应用程序、信用卡事务、电子邮件等

### 方法（详细描述）

+ **安全方法**<br>
HTTP 定义了一组被称为安全方法的方法。GET 和 HEAD 方法都被认为是安全的，这以为这 GET 和 HEAD 方法的 HTTP 请求不会产生什么动作（也就是不会对服务器产生一些行为，比如服务存储、删除、更改资源等，那 POST 之类的方法就会产生一些行为）<br>
安全方法并不一定是什么动作都不执行（实际上这由 web 开发者决定）。使用安全方法的目的就是当使用可能引发某一动作的不安全方法时，允许 HTTP 应用程序开发者通知用户，比如用不安全的方法发起请求，会在服务器上产生一些事件（你的信用卡支付费用）

+ **GET**<br>
GET 是最常用的方法。通常用于请求服务器发送某个资源。HTTP/1.1 要求服务器实现此方法
<br><br>
```
    请求报文
  |----------------------------------------|
  | GET /seasonal/index-fall.html HTTP/1.1 |
  | Host: www.joes-hardware.com            |
  | Accept: *                              |
  |----------------------------------------|

    响应报文
  |---------------------------------------------|
  | HTTP/1.1 200 OK                             |
  | Content-Type: text/html                     |
  | Content-Length: 617                         |
  |                                             |
  | <HTML>                                      |
  | <HEAD><TITLE> Joeos Special Offers </TITLE> |
  | ...                                         |
  |---------------------------------------------|
```

+ **HEAD**<br>
HEAD 方法与 GET 方法行为类似，但服务器在响应中只返回首部，不会返回实体的主体部分，这样就允许客户端为获取实际资源的情况下，对资源的首部进行检查，HTTP/1.1 规范，必须实现 HEAD 方法。使用 HEAD，可以：
  1. 在不获取资源的情况下了解资源情况（比如判断其类型）
  2. 通过查看响应首部的状态码，看看某个对象是否存在
  3. 通过查看首部，测试资源是否被修改了
<br><br>
```
    请求报文
  |-----------------------------------------|
  | HEAD /seasonal/index-fall.html HTTP/1.1 |
  | Host: www.joes-hardware.com             |
  | Accept: *                               |
  |-----------------------------------------|

    响应报文（没有实体的主体部分）
  |-----------------------------------------|
  | HTTP/1.1 200 OK                         |
  | Content-Type: text/html                 |
  | Content-Length: 617                     |
  |-----------------------------------------|
```

+ **PUT**<br>
与 GET 从服务器读取文档相反，PUT 方法会向服务器写入文档。有些发布系统允许用户创建 web 页面，并用 PUT 直接将其安装到 web 服务器上去。PUT 方法的语义就是让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，如果那个 URL 已经存在，就用这个主体替代它。<br>
因为 PUT 方法允许用户对内容进行修改，所以很多 web 服务器都要求在执行 PUT 之前，用密码登录。详情见[第十二章](../three_part/chapter_twelve.md)
<br><br>
```
    请求报文
  |----------------------------------------|
  | PUT /product-list.txt HTTP/1.1         |
  | Host: www.joes-hardware.com            |
  | Content-type: text/plain               |
  | Content-Length: 34                     |
  |                                        |
  | Updated product list coming soon!      |
  |----------------------------------------|

    响应报文（服务器更新/创建资源/product-list.txt，并将其写入自己的磁盘）
  |---------------------------------------------------------|
  | HTTP/1.1 201 Created                                    |
  | Location: http://www.joes-hardware.com/product-list.txt |
  | Content-Type: text/plain                                |
  | Content-Length: 47                                      |
  |                                                         |
  | http://www.joes-hardware.com/product-list.txt           |
  |---------------------------------------------------------|
```

+ **POST**<br>
POST 方法起初是用来向服务器输入数据的（POST 用于向服务器发送数据，PUT 用于向服务器上的资源`例如文件`中存储数据），实际上，通常会用它来支持 HTML 中的表单（但是我感觉现在 xhr 用的多些，表单都不怎么用了，虽然用表单没有跨域，但是很难做到无刷新）。

+ **TRACE**<br>
客户端发起一个请求时，这个请求可能会穿过防火墙、代理、网关或者其他一些应用程序。每个中间节点都可能会修改原始的 HTTP 请求。TRACE 方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子<br>
TRACE 请求会在目的地服务器端发起一个 “环回” 诊断。行程最后一站的服务器会弹回一条 TRACE 响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看所有 HTTP 中间应用程序的请求/响应链上，原始报文是否、以及、如何被毁坏或修改
<br><br>
```
    请求报文
  |----------------------------------|            |----------------------------------|
  | TRACE /product-list.txt HTTP/1.1 |  经过代理    | TRACE /product-list.txt HTTP/1.1 |
  | Accept: *                        | -------->  | Host: www.joes-hardware.com      |
  | Host: www.joes-hardware.com      |            | Accept: *                        |
  |----------------------------------|            | Via: 1.1 proxy3.company.com      |
                                                  |----------------------------------|
                                                                  |
                                                                  |
                                                                  v
                                                    响应报文
  |----------------------------------|            |----------------------------------|
  | HTTP/1.1 200 OK                  |            | HTTP/1.1 200 OK                  |
  | Content-Type: text/plain         |            | Content-Type: text/plain         |
  | Content-Length: 96               |            | Content-Length: 96               |
  | Via: 1.1 proxy3.company.com      |  经过代理    |                                  |
  |                                  | <--------  | TRACE /product-list.txt HTTP/1.1 |
  | TRACE /product-list.txt HTTP/1.1 |            | Host: www.joes-hardware.com      |
  | Host: www.joes-hardware.com      |            | Accept: *                        |
  | Accept: *                        |            | Via: 1.1 proxy3.company.com      |
  | Via: 1.1 proxy3.company.com      |            |----------------------------------|
  |----------------------------------|
```
TRACE 方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链，也可以用来查看代理和其他应用程序对用户请求所产生的效果<br>
但是它也有缺点，它假定中间应用程序对各种不同类型请求（GET、POST、HEAD等）的处理是相同的。比如代理可能会将 POST 请求直接发送给服务器，将 GET 请求发送给另外一个 HTTP 应用程序（比如 web 缓存），TRACE 并不提供区分这些方法的机制。通常，中间应用程序会自行决定对 TRACE 请求的处理方式<br><br>

TRACE 请求中不能带有实例的主体部分。TRACE 响应的实体主体部分包含了响应服务器收到的请求的精确副本

+ **OPTIONS**<br>
OPTIONS 方法请求 web 服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法（有些服务器可能只支持对一些特殊类型的对象使用特定的操作）<br>
这为客户端提供了一种手段，使其不用实际访问资源就能判定访问各种资源的最优方式
<br><br>
```
    请求报文                                    响应报文
  |-----------------------------|           |--------------------------------|   由于请求的是可为所有资源
  | OPTIONS * HTTP/1.1          |           | HTTP/1.1 200 OK                |   使用的选项，所以服务器仅
  | Host: www.joes-hardware.com |           | Allow: GET, POST, PUT, OPTIONS |   返回了它支持的可通用于各
  | Accept: *                   |           | Content-Length: 0              |   种资源的方法
  |-----------------------------|           |--------------------------------|
```

+ **DELETE**<br>
DELETE 方法所做的事情就是请服务器删除请求 URL 所指定的资源。但是，客户端应用程序无法保证删除操作一定会被执行。因为 HTTP 规范允许服务器在不通知客户端的情况下撤销请求
<br><br>
```
    请求报文（客户端认为资源以及被删除了）                 响应报文
  |-----------------------------------|           |-----------------------------|
  | DELETE /product-list.txt HTTP/1.1 |  ---->    | HTTP/1.1 200 OK             |  从服务器磁盘中删除文件
  | Host: www.joes-hardware.com       |           | Content-Type: text/plain    |  product-list.txt
  |-----------------------------------|  <----    | Content-Length: 54          |
                                                  |                             |
                                                  | I have your delete request, |
                                                  | will take time to process.  |
                                                  |-----------------------------|
```

+ **扩展方法**<br>
HTTP 被设计成字段可扩展的，这样新的特性就不会使老的软件失效了。扩展方法指的就是没有在 HTTP/1.1 规范中定义的方法。以下为一些常用的扩展方法：

| 方法    | 描述                                        |
|-------|-------------------------------------------|
| LOCK  | 允许用户“锁定”资源 -- 比如在编辑某个资源的时候将其锁定，防止别人同时对其修改 |
| MKCOL | 允许用户创建资源                                  |
| COPY  | 便于在服务器上复制资源                               |
| MOVE  | 在服务器上移动资源                                 |

并不是所有的扩展方法都是在正式规范中定义的。所以最好对扩展方法宽容一些，如果能够在不破坏端到端行为的情况下，代理应该尝试传递这些报文，如果可能会破坏端到端行为，则应该以 `501 Not Implemented` 状态码进行响应。按照惯例，“对所发送的内容要求严一点，对所接收的内容宽容一点” 来处理扩展方法


## 状态码
HTTP 状态码被分为五大类

+ **100 ~ 199 -- 信息性状态码**<br>
HTTP/1.1 向协议引入了信息性状态码，关于其复杂性和感知价值存在一些争论，而受到限制。以下为已定义的状态码：
```html
  -------------------------------------------------------------------------------------------------------
    状态码 |       原因短句       |                            含    义
  -------------------------------------------------------------------------------------------------------
    100   |       Continue      | 说明收到请求的初始部分，请求客户端继续，发送了这个状态码之后，服务器在收到请求之后
          |                     | 必须进行响应。更多信息见附录 C 中的 Expect 首部介绍
  -------------------------------------------------------------------------------------------------------
    101   | Switching Protocols | 说明服务器正在根据客户端的指定，将协议切换成 Update 首部所列的协议
  -------------------------------------------------------------------------------------------------------
```

`100 Continue` 有时候会让人很糊涂，所以这里进行详细解释

1) **客户端与 100 Continue**<br>
如果客户端在向服务器发送一个实体，并且愿意在发送实体之前等待 `100 Continue` 响应，那么客户端就要发送一个携带了值为 `100 Continue` 的 Expect 请求首部。如果客户端没有发送实体，就不应该发送 `100 Continue Expect` 首部，因为这样会让服务器产生误<br>
从很多方面来看，`100 Continue` 都是一种优化，客户端应该在发送一个服务器无法处理或者使用大实体时，才应该使用 `100 Contine`，而且客户端发送了值为 `100 Continue` 的 Expect 首部的时候不应该永远在那儿等待服务器发送 `100 Continue` 响应，超过一定时间之后，客户端应该直接将实体发送出去。客户端程序实现者还应该做好应对非预期的 `100 Continue` 响应，有些出错的 HTTP 应用程序会不合时宜的发送这个状态码

2) **服务器与 100 Continue**<br>
如果服务器收到了一条带有值为 `100 Continue` 的 Expect 首部请求，它会用 `100 Continue` 响应或者一条错误码来响应。服务器永远不应该向没有发送 `100 Continue` 期望的客户端发送 `100 Continue` 状态码（有些出错服务器会这么做）<br>
如果服务器在有机会发送 `100 Continue` 响应之前就收到了部分或者全部的实体，说明客户端已经决定继续发送数据了，这样，服务器就不需要发送这个状态码了，但服务器读完请求之后，还是应该为请求发送一个最终状态码（可以跳过 `100 Continue` 状态）<br>
最后，如果服务器收到了带有 `100 Continue` 期望的请求，而且它决定在读取实体主体部分之前结束请求（比如出错），就不应该仅仅是发送一条响应并关闭连接，因为这样会妨碍客户端接收响应，详见[第四章](./chapter_four.md)

3) **代理与100 Continue**<br>
如果代理收到了一条带有 xx 的请求，它需要做几件事。如果代理知道[下一跳服务器](../two_part/chapter_six.md)是 HTTP/1.1 兼容的，或并不知道下一跳服务器与哪个版本兼容，它都应该将 Expect 首部放在请求中向下转发。如果它知道下一跳服务器只能与 HTTP/1.1 之前的版本兼容，就应该以 `417 Expectation Failed` 错误进行响应（还有一种合理的方法，是先向客户端返回 `100 Continue`， 然后删除 Expect 首部，再向服务器转发）<br>
如果代理决定与 HTTP/1.0 或之前版本兼容的客户端，在其请求中放入 Expect 首部和 `100 Continue` 值，那么它就不应该将 `100 Continue` 响应转发给客户端，因为客户端可能不知道该拿它怎么办

<br><br><br>
+ **200 ~ 299 -- 成功状态码**<br>
以下列出了已定义的成功状态码

```html
  ---------------------------------------------------------------------------------------------------------
  状态码 |  原因短句   |                                 含      义
  ---------------------------------------------------------------------------------------------------------
    200 |    OK      | 请求没问题，实体的主体部分包含了所请求的资源
  ---------------------------------------------------------------------------------------------------------
    201 |  Created   | 用于创建服务器对象的请求（比如 PUT）。响应的实体主体部分中应该包含各种引用了已创建的资源的 URL，
        |            | Location 首部① 包含的则是最具体的引用。服务器必须在发送这个状态码之前创建好对象
  ---------------------------------------------------------------------------------------------------------
    202 | Accepted   | 请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求；这只是意味着接受请求时，它
        |            | 看起来是有效的。服务器应该在实体的主体部分包含对请求状态的描述，或许还应该有对请求完成时间的估计（或
        |            | 者包含一个指针，指向可以获取此信息的位置
  ----------------------------------------------------------------------------------------------------------
    203 | Non-Author | 实体首部包含的信息不是来自源服务器，而是来自资源的一份副本。如果中间节点上有一份资源副本，但无法或者
        | itative    | 没有对它所发送的与资源有关的元信息（首部）进行验证，就会出现这种情况。这种响应并不是非用不可；如果实
        | Information| 体首部来自源服务器，响应为 200 状态的应用程序就可以将其作为一种可选性使用
  ----------------------------------------------------------------------------------------------------------
    204 | No Content | 响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要用于在浏览器不转为显示新文档的情况下，
        |            | 对其进行更新（比如刷新一个表单页面）
  ----------------------------------------------------------------------------------------------------------
    205 |   Reset    | 另一个主要用于浏览器的代码。负责告知浏览器清除当前页面中的所有 HTML 表单元素
        |  Content   |
  ----------------------------------------------------------------------------------------------------------
    206 |  Partial   | 成功执行了一部分或 Range 请求。客户端可以通过一些特殊的首部来获取部分或者某个范围内的文档 -- 这个
        |  Content   | 状态码就说明范围请求成功了。206 响应中必须包含 Content-Range、Date、Etag 或 Content-Location
        |            | 首部，更多见第十五章②
  ----------------------------------------------------------------------------------------------------------
```
①[Location 首部](./#dfasdfsdaf)<br>
②[十五章](../four_part/chapter_fifteen.md)

<br><br><br>
+ **300 ~ 399 -- 重定向状态码**<br>
重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应而不是资源的内容。如果资源以被移动，就可发送一个重定向状态码和一个可选的 Location 首部来告知客户端资源已被移走，以及可以在哪里找到它。<br>
总之，对那些包含了重定向状态码的非 `HEAD` 请求进行响应时，最好要包含一个实体，并在实体中包含描述信息和指向（多个）重定向 URL 的链接<br>
还可以通过某些重定向状态码对资源的应用程序本地副本与源服务器上的资源进行验证。比如，HTTP 应用程序可以查看其资源的本地副本是否仍然是最新的，或者在源服务器上资源是否被修改过，请看以下示例

```
  客户端发送了一个特殊的 `If-Modified-Since` 首部，说明只读取 1997/10 之后修改过的文档。
  在这个日期之后，文档并未被修改，所以服务器送了一个 `304` 状态码

    请求报文                                                     响应报文（文档未被修改过）
  |-------------------------------------------------|         |---------------------------|
  | GET /seasonal/index-fall.html HTTP/1.1          |         | HTTP/1.1 304 Not Modified |
  | Host: www.joes-hardware.com                     |         | ...                       |
  | Accept: *                                       |         |---------------------------|
  | If-Modified-Since: Fri, Oct 3 1997 02:16:00 GMT |
  |-------------------------------------------------|

  原始文档未被修改过，所以浏览器显示的是本地副本
```

```html
  -------------------------------------------------------------------------------------------------------
    状态码 |       原因短句       |                            含    义
  -------------------------------------------------------------------------------------------------------
    300   | Multiple Choices    | 客户端请求一个实际指向多个资源的 URL 时会返回这个状态码，比如服务器上有某个 HTML
          |                     | 文档的英语和法语版本。返回这个代码时，会带有一个选项列表；这样用户就可以选择他希望
          |                     | 使用的那一项了。有多个版本可以使用，客户端需要沟通解决，详情见十七章①。服务器可以
          |                     | 在 Location 首部包含首选 URL
  -------------------------------------------------------------------------------------------------------
    301   | Moved Permanently   | 在请求的 URL 已被移除时使用。响应的 Location 首部中应包含资源现状所在处的 URL
  -------------------------------------------------------------------------------------------------------
    302   | Found               | 与 301 状态码类似；但是，客户端应该使用 Location 首部给出的 URL 来临时定位资源。
          |                     | 将来的请求仍应使用老的 URL
  -------------------------------------------------------------------------------------------------------
    303   | See Other           | 告知客户端应该用另一个 URL 来获取资源。新的 URL 位于响应报文的 Location 首部。
          |                     | 其主要目的是允许 POST 请求的响应将客户端定向到某个资源上去
  -------------------------------------------------------------------------------------------------------
    304   | Not Modified        | 客户端可以通过所包含的请求首部，使其请求变成有条件的。如果客户端发起了一个条件 GET
          |                     | 请求，而最近资源未被修改的话，就可以用这个状态码来说明资源未被修改。带有这个状态码
          |                     | 的响应不应该包含实体的主体部分
  -------------------------------------------------------------------------------------------------------
    305   | Use Proxy           | 用来说明必须通过一个代理来访问资源；代理的位置由 Location 首部给出。很重要的一点是，
          |                     | 客户端是相对某个特定资源来解析这条响应的，不能假定所有请求，甚至所有对持有所请求资源
          |                     | 的服务器的请求都通过这个代理进行。如果客户端错误地让代理介入了某条请求，可能会引发破
          |                     | 坏性的行为，而且会造成安全漏洞
  -------------------------------------------------------------------------------------------------------
    306   | （未使用 ）           | 当前未使用
  -------------------------------------------------------------------------------------------------------
    307   | Temporary Redirect  | 与 301 状态码类似；但客户端应该使用 Location 首部给出的 URL 来临时定位资源。将来
          |                     | 的请求应该使用老的 URL
  -------------------------------------------------------------------------------------------------------
```
①[十七章](../four_part/chapter_seventeen.md)<br><br>

**302、 303、 307 状态码详解**
+ 302、303和307状态码存在一些交叉。这些状态码的用法有着细微的差别，大部分的差别都源于 HTTP/1.0 和 HTTP/1.1 应用程序对这些状态码处理方式不同

+ 当 HTTP/1.0 客户端发起一个 POST 请求，并受到 302 重定向响应时，它会根据 Location 首部的 URL 发起一个 GET 请求，而且不是向原始请求那样发起一个 POST 请求。HTTP/1.0 服务器也希望 HTTP/1.0 客户端这么做

+ 问题出在 HTTP/1.1。 HTTP/1.1 规范使用 303 状态码来实现同样的行为。为了避开这个问题，HTTP/1.1 规范指出，对于 HTTP/1.1 客户端，用 307 状态码取代 302 状态码来进行临时重定向。这样服务器就可以将 302 状态码保留起来，为 HTTP/1.0 客户端使用了。（个人理解 302 这个状态码在 1.0 的协议中有两种功能，分别对应这个 1.1 协议中的 303 和 307，1.1 协议应该是把这俩功能拆开了，正好是 1.1 版本的目的，校正设计中的结构性缺陷，明确语义）

+ 这样一来，客户端在选择适当的重定向状态码时，就需要查看客户端的 HTTP 版本了

<br><br><br>
+ **400 ~ 499 -- 客户端错误状态码**<br>
以下为客户端错误状态码以及原因短句：<br>

```html
  -------------------------------------------------------------------------------------------------------
    状态码 |       原因短句       |                            含    义
  -------------------------------------------------------------------------------------------------------
    400   | Bad Request         | 用于告知客户端它发送了一个错误的请求
  -------------------------------------------------------------------------------------------------------
    401   | Unauthorized        | 与适当的首部一同返回，在这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证。
          |                     | 认证内容详见第十二章①
  -------------------------------------------------------------------------------------------------------
    402   | Payment Required    | 这个状态码还未使用，但已经被保留
  -------------------------------------------------------------------------------------------------------
    403   | Forbidden           | 用于说明请求被服务器拒绝了。如果服务器想说明为什么，可以包含主体的实体部分来对原因进
          |                     | 行描述。但通常是在服务器不想说明原因的时候使用
  -------------------------------------------------------------------------------------------------------
    404   | Not Found           | 用于说明服务器无法找到所请求的 URL。通常会包含一个实体，以便客户端显示给用户看
  -------------------------------------------------------------------------------------------------------
    405   | Method Not Allowed  | 发起的请求中带有所请求的 URL 不支持的方法时，使用此状态码。应该在响应中包含 Allow
          |                     | 首部，以告知客户端对所请求的资源可以使用哪些方法
  -------------------------------------------------------------------------------------------------------
    406   | Not Acceptable      | 客户端可以指定参数来说明它们愿意接收什么类型的实体。服务器没有与客户端可接受的 URL
          |                     | 相匹配的资源时，使用此代码。通过，服务器会包含一些首部，以便客户端弄清楚为什么请求
          |                     | 无法满足。详情见第十七章②
  -------------------------------------------------------------------------------------------------------
    407   | Proxy Authentication| 与 401 状态码类似，但用于要求对资源进行认证的代理服务器
          | Required            |
  -------------------------------------------------------------------------------------------------------
    408   | Request Timeout     | 如果客户端完成请求所花的时间太长，服务器可以回送此状态码，并关闭连接。超时时长随服务
          |                     | 器的不同而不同，但通常对所有的合法请求来说，都是够长的
  -------------------------------------------------------------------------------------------------------
    409   | Conflict            | 用于说明请求可能在资源上引发的一些冲突。服务器担心请求会引发冲突时，可以发送此状态码。
          |                     | 响应中应该包含描述冲突的主体
  -------------------------------------------------------------------------------------------------------
    410   | Gone                | 与 404 类似，只是服务器曾经拥有过此资源。主要用于 web 站点的维护，这样服务器的管理
          |                     | 者就可以在资源被移除的情况下通知客户端了
  -------------------------------------------------------------------------------------------------------
    411   | Length Required     | 服务器要求在请求报文中包含 Content-Length 首部时使用
  -------------------------------------------------------------------------------------------------------
    412   | Precondition Failed | 客户端发起了条件请求，且其中一个条件失败了的时候使用。客户端包含了 Expect 首部时发
          |                     | 起的就是条件请求。更多详情见附录 C 中的 Expect 部分
  -------------------------------------------------------------------------------------------------------
    413   | Request Entity Too  | 客户端发送的实体主体部分比服务器能够或者希望处理的要大时，使用此状态码
          | Large               |
  -------------------------------------------------------------------------------------------------------
    414   | Request URL Too     | 客户端所发请求中的请求 URL 比服务器能够或者希望处理的要长时，使用此状态码
          | Long                |
  -------------------------------------------------------------------------------------------------------
    415   | Unsupported Media   | 服务器无法理解或者无法支持客户端所发送实体的内容类型时，使用此状态码
          | Type                |
  -------------------------------------------------------------------------------------------------------
    416   | Requested Range Not | 请求报文所请求的是指定资源的某个范围，而此范围无效或者无法满足，使用此状态码
          | Satisfiable         |
  ------------------------------------------------------------------------------------------------------
    417   | Expectation Failed  | 请求的 Expect 请求首部包含了一个期望，但服务器无法满足此期望时，使用此状态码。
          |                     | 如果代理或者其他中间应用程序有确切证据说明源服务器会为某请求产生一个失败的期望，就可
          |                     | 以发送这个响应状态码
  -------------------------------------------------------------------------------------------------------
```
①[十二章](../three_part/chapter_twelve.md)<br>
②[十七章](../four_part/chapter_seventeen)

<br><br><br>
+ **500 ~ 599 -- 服务器错误状态码**<br>
以下为服务器错误状态码以及原因短句：<br>

```html
 -------------------------------------------------------------------------------------------------------
    状态码 |       原因短句       |                            含    义
  -------------------------------------------------------------------------------------------------------
    500   | Internal Server     | 服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态码
          | Error               |
  -------------------------------------------------------------------------------------------------------
    501   | Not Implemented     | 客户端发起的请求超出服务器的能力范围（比如，使用了服务器不支持的方法）时，使用此状态码
  -------------------------------------------------------------------------------------------------------
    502   | Bad Gateway         | 作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应（比如，它无法连
          |                     | 接到其父网关）时，使用此状态码
  -------------------------------------------------------------------------------------------------------
    503   | Service Unavailable | 用来说明服务器现在无法为请求提供服务，但将来可以。如果服务器知道什么时候资源会变为可
          |                     | 用的，可以在响应中包含一个 Retry-After 首部
  -------------------------------------------------------------------------------------------------------
    504   | Gateway Timeout     | 与状态码 408 类似，只是这里的响应来自一个网关或代理，它们在等待另一服务器对其请求进
          |                     | 行响应时超时了
  -------------------------------------------------------------------------------------------------------
    505   | HTTP Version Not    | 服务器收到的请求使用了它无法或不愿意支持的版本协议时，使用此状态码。有些服务器应用程
          | Supported           | 序会选择不支持协议的早期版本
  -------------------------------------------------------------------------------------------------------
```
<br><br><br>

## 首部
首部与方法配合工作，共同决定了客户端和服务器能做什么事情。附录 C 对所有首部进行了详细的总结。首部可以分为五个类型：通用首部、请求首部、响应首部、实体首部、扩展首部

+ **通用首部**<br>
有些首部提供了与报文信息相关的最基本信息，它们被称为通用首部。它们就像和事儿佬一样，不论报文是何类型，都为其提供一些有用的信息

```
  以下为通用信息性首部
  -------------------------------------------------------------------------------------------------------
    首  部            |                   描         述
  -------------------------------------------------------------------------------------------------------
    Connection        | 允许客户端和服务器指定与请求/响应连接有关的选项
  -------------------------------------------------------------------------------------------------------
    Date              | 提供日期和事件标志，说明报文是什么时候创建的
  -------------------------------------------------------------------------------------------------------
    MIME-Version      | 给出了发送端使用的 MIME 版本
  -------------------------------------------------------------------------------------------------------
    Trailer           | 如果报文采用了分块传输编码方式，就可以用这个首部列出位于报文拖挂（trailer）部分的首部集合①
  -------------------------------------------------------------------------------------------------------
    Transfer-Encoding | 告知客户端为了保证报文的可靠传输，对报文采用了什么编码方式
  -------------------------------------------------------------------------------------------------------
    Update            | 给出了发送端可能想要 “升级” 使用的新版本协议
  -------------------------------------------------------------------------------------------------------
    Via               | 显示了报文经过的中间节点（代理、网关）
  -------------------------------------------------------------------------------------------------------
```
① [15.6.3 节详细讨论了分块传输编码](../four_part/chapter_fifteen.md)<br>
```
  以下为通用缓存首部
  -------------------------------------------------------------------------------------------------------
    首  部            |                   描         述
  -------------------------------------------------------------------------------------------------------
    Cache-Control     | 用于随报文传送缓存提示
  -------------------------------------------------------------------------------------------------------
    Pragma            | 另一种随报文传送指示的方式，但并不专用于缓存
  -------------------------------------------------------------------------------------------------------

  从技术角度看，Pragma 是一种请求首部。从未被指定用于响应首部。由于经常被错误地用于响应首部，很多客户端和代理都会将 Pragma
  解释为响应首部，但其确切语义并未得到很好地定义。任何情况下 Cache-Control 的使用都优于 Pragma
```
<br><br><br>

+ **请求首部**<br>
请求首部是只在请求报文中有意义的首部。用于说明是谁或什么在发送请求、请求源自何处，或者客户端的喜好及能力

```
  以下为请求信息性首部
  -------------------------------------------------------------------------------------------------------
    首  部            |                   描         述
  -------------------------------------------------------------------------------------------------------
    Client-IP         | 提供了运行客户端的机器的IP地址 
  -------------------------------------------------------------------------------------------------------
    From              | 提供了客户端用户的E-mail地址
  -------------------------------------------------------------------------------------------------------
    Host              | 出了接收请求的服务器的主机名和端口号
  -------------------------------------------------------------------------------------------------------
    Referer           | 提供了包含当前请求URI的文档的URL
  -------------------------------------------------------------------------------------------------------
    User-Agent        | 将发起请求的应用程序名称告知服务器
  -------------------------------------------------------------------------------------------------------
    UA-Color          | 提供了与客户端显示器的显示颜色有关的信息
  -------------------------------------------------------------------------------------------------------
    UA-CPU            | 给出了客户端CPU的类型或制造商
  -------------------------------------------------------------------------------------------------------
    UA-Disp           | 提供了与客户端显示器（屏幕）能力有关的信息
  -------------------------------------------------------------------------------------------------------
    UA-OS             | 给出了运行在客户端机器上的操作系统名称及版本
  -------------------------------------------------------------------------------------------------------
    UA-Pixeis         | 提供了客户端显示器的像素信息
  -------------------------------------------------------------------------------------------------------

  RFC 2616 没有定义 Client-IP 和 UA-* 首部，但很多 HTTP 客户端应用程序都实现了这两个首部
  尽管有些客户端实现了 UA-* 首部，但我们认为 UA-* 首部是有副作用的。不应该将内容，尤其是HTML，局限于特定的客户端配置
```

```
  以下为 Accept 首部
  -------------------------------------------------------------------------------------------------------
    首  部            |                   描         述
  -------------------------------------------------------------------------------------------------------
    Accept            | 告诉服务器能够发送哪些媒体类型
  -------------------------------------------------------------------------------------------------------
    Accept-Charset    | 告诉服务器能够发送哪些字符集
  -------------------------------------------------------------------------------------------------------
    Accept-Encoding   | 告诉服务器能够发送哪些编码方式
  -------------------------------------------------------------------------------------------------------
    Accept-Language   | 告诉服务器能够发送哪些语言
  -------------------------------------------------------------------------------------------------------
    TE                | 告诉服务器可以使用哪些扩展传输编码
  -------------------------------------------------------------------------------------------------------

  Accept 首部为客户端提供了一种将其喜好和能力告知服务器的方式，包括它们想要什么，可以使用什么，以及最重要的，它们不想要什么。
  这样，服务器就可以根据这些额外信息，对要发送的内容做出更明智的决定
```

```
  以下为条件请求首部
  -------------------------------------------------------------------------------------------------------
    首  部              |                 描         述
  -------------------------------------------------------------------------------------------------------
    Expect              | 允许客户端列出某请求所要求的服务器行为
  -------------------------------------------------------------------------------------------------------
    If-Match            | 如果实体标记与文档当前的实体标记相匹配，就获取这份文档①
  -------------------------------------------------------------------------------------------------------
    If-modified-Since   | 除非在某个指定的日期之后资源被修改过，否则就限制这个请求
  -------------------------------------------------------------------------------------------------------
    If-None-Match       | 如果提供的实体标记与当前文档的实体标记不相符，就获取文档
  -------------------------------------------------------------------------------------------------------
    If-Range            | 允许对文档的某个范围进行条件请求
  -------------------------------------------------------------------------------------------------------
    If-Unmodified-Since | 除非在某个指定日期之后资源没有被修改过，否则就限制这个请求
  -------------------------------------------------------------------------------------------------------
    Range               | 如果服务器支持范围请求，就请求资源的指定范围②
  -------------------------------------------------------------------------------------------------------

  通过条件请求首部，客户端可以为请求加上限制，要求服务器在对请求进行响应之前，确保某个条件为真
```

```
  以下为安全请求首部
  -------------------------------------------------------------------------------------------------------
    首  部           |                 描         述
  -------------------------------------------------------------------------------------------------------
    Authorization   | 允许客户端列出某请求所要求的服务器行为
  -------------------------------------------------------------------------------------------------------
    Cookie          | 客户端用它向服务器传送一个令牌——它并不是真正的安全首部，但确实隐含了安全功能③
  -------------------------------------------------------------------------------------------------------
    Cookie2         | 用来说明请求端支持的cookie版本
  -------------------------------------------------------------------------------------------------------

  HTTP 本身就支持一种简单的机制，可以对请求进行质询 / 响应认证。
  这种机制要求客户端在获取特定的资源之前，先对自身进行认证，这样就可以使事务稍微安全一些
```

```
  以下为代理请求首部
  -------------------------------------------------------------------------------------------------------
    首  部               |             描         述
  -------------------------------------------------------------------------------------------------------
    Max-Forward         | 在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数 -- 与 TRACE 方法一同使用④
  -------------------------------------------------------------------------------------------------------
    Proxy-Authorization | 与 Authorization 首部相同，但这个首部是在与代理进行认证时使用的
  -------------------------------------------------------------------------------------------------------
    Proxy-Connection    | 与 Connection 首部相同，但这个首部是在与代理建立连接时使用的
  -------------------------------------------------------------------------------------------------------

  第六章对这些代理首部进行了详细的讨论
```

①更多有关实体标记的内容详见[第七章](../two_part/chapter_seven.md)<br>
②更多有关 Range 首部的内容详见[第十五章](../four_part/chapter_fifteen.md)<br>
③RFC 2616 并没有定义 Cookie 首部，在第[十一章](../three_part/chapter_eleven.md)详细讨论了该首部<br>
④详见[第六章](../two_part/chapter_six.md)
<br><br><br>

+ **响应首部**<br>
响应报文有自己的响应首部集。响应首部为客户端提供了一些额外信息，比如谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令。这些首部有助于客户端处理响应，并在将来发起更好的请求

```
  以下为响应信息性首部
  -------------------------------------------------------------------------------------------------------
    首  部           |             描         述
  -------------------------------------------------------------------------------------------------------
    Age             | 从最初创建开始）响应持续时间①
  -------------------------------------------------------------------------------------------------------
    Public②        | 服务器为其资源支持的请求方法列表
  -------------------------------------------------------------------------------------------------------
    Retry-After     | 如果资源不可用的话，在此日期或时间重试
  -------------------------------------------------------------------------------------------------------
    Server          | 服务器应用程序软件的名称和版本
  -------------------------------------------------------------------------------------------------------
    Title③         | 对HTML文档来说，就是HTML文档的源端给出的标题 
  -------------------------------------------------------------------------------------------------------
    Warning         | 比原因短语中更详细一些的警告报文
  -------------------------------------------------------------------------------------------------------
```

```
  以下为协商首部④
  -------------------------------------------------------------------------------------------------------
    首  部           |             描         述
  -------------------------------------------------------------------------------------------------------
    Accept-Ranges   | 对此资源来说，服务器可接受的范围类型
  -------------------------------------------------------------------------------------------------------
    Vary            | 服务器查看的其他首部的列表，可能会使响应发生变化；也就是说，这是一个首部列表，服务器会根据这些首部
                    | 的内容挑选出最适合的资源版本发送给客户端
  -------------------------------------------------------------------------------------------------------
```

```
  以下为安全响应首部
  -------------------------------------------------------------------------------------------------------
    首  部              |          描         述
  -------------------------------------------------------------------------------------------------------
    Proxy-Authenticate | 来自代理的对客户端的质询列表
  -------------------------------------------------------------------------------------------------------
    WWW-Authenticate   | 来自服务器的对客户端的质询列表
  -------------------------------------------------------------------------------------------------------
    Set-Cookie         | 不是真正的安全首部，但隐含有安全功能；可以在客户端设置一个令牌，以便服务器对客户端进行标识
  -------------------------------------------------------------------------------------------------------
    Set-Cookie2        | 与Set-Cookie 类似，RFC 2965 Cookie 定义，详见第十一章
  -------------------------------------------------------------------------------------------------------
```

①暗示响应是通过中间节点，很可能是从代理的缓存传送过来的<br>
②Public 首部是在 RFC 2068 中定义的，但在最新的 HTTP 定义（RFC 2616）中并没有出现<br>
③RFC 2616 并没有定义 Title 首部<br>
④第[十七章](../four_part/chapter_seventeen.md)详细讨论了协商
<br><br><br>

+ **实体首部**<br>
有很多首部可以用来描述 HTTP 报文的负荷。由于请求和响应报文中都可能包含实体部分，所以在这**两种类型的报文中都可能出现这些首部**。总之，实体首部可以告知报文的接收者它在对什么进行处理

```
  以下为实体的信息性首部
  -------------------------------------------------------------------------------------------------------
    首  部           |          描         述
  -------------------------------------------------------------------------------------------------------
    Allow           | 列出了可以对此实体执行的请求方法
  -------------------------------------------------------------------------------------------------------
    Location        | 告知客户端实体实际上位于何处；用于将接收端定向到资源的（可能是新的）位置（URL）上去
  -------------------------------------------------------------------------------------------------------
```

```
  以下为内容首部
  -------------------------------------------------------------------------------------------------------
    首  部            |          描         述
  -------------------------------------------------------------------------------------------------------
    Content-Base①    | 解析主体中的相对 URL 时使用的基础 URL
  -------------------------------------------------------------------------------------------------------
    Content-Encoding | 对主体执行的任意编码方式
  -------------------------------------------------------------------------------------------------------
    Content-Language | 理解主体时最适宜使用的自然语言
  -------------------------------------------------------------------------------------------------------
    Content-Length   | 主体的长度或尺寸
  -------------------------------------------------------------------------------------------------------
    Content-Location | 资源实际所在位置
  -------------------------------------------------------------------------------------------------------
    Content-MD5      | 主体的 MD5 校验和
  -------------------------------------------------------------------------------------------------------
    Content-Range    | 在整个资源中此实体表示的字节范围
  -------------------------------------------------------------------------------------------------------
    Content-Type     | 整个主体的对象类型
  -------------------------------------------------------------------------------------------------------

  内容首部提供了与实体内容有关的特定信息，说明了其类型、尺寸以及处理它所需的其他有用信息
  比如，Web 浏览器可以通过查看返回的内容类型，得知如何显示对象
```

```
  以下为实体缓存首部
  -------------------------------------------------------------------------------------------------------
    首  部           |          描         述
  -------------------------------------------------------------------------------------------------------
    ETag            | 与此实体相关的实体标记②
  -------------------------------------------------------------------------------------------------------
    Expires         | 实体不再有效，要从原始的源端再次获取此实体的日期和时间
  -------------------------------------------------------------------------------------------------------
    Last-Modified   | 这个实体最后一次被修改的日期和时间
  -------------------------------------------------------------------------------------------------------

  通用的缓存首部说明了如何或什么时候进行缓存
  实体的缓存首部提供了与被缓存实体有关的信息 -- 比如，验证已缓存的资源副本是否仍然有效所需的信息，
    以及更好地估计已缓存资源何时失效所需的线索

  第七章③深入讨论了 HTTP 请求和响应的缓存
```

①RFC 2616 中没有定义 Content-Base 首部<br>
②实体标记本质上来说就是某个特定资源版本的标识符
③[第七章](../two_part/chapter_seven.md)


<br><br><br>
[**上一章：URL 与 资源**](./chapter_two.md)<pre>                                                              </pre>[**下一章：连接管理**](./chapter_two.md)