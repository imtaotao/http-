# 3.HTTP 报文
本章内容较多，主要介绍如下：

- 报文是如何流动的
- HTTP 报文的三个组成部分（起始行、首部和实体的主体部分）
- 请求和响应报文之间的区别
- 请求报文支持的各种方法
- 和响应报文一起返回的各种状态码
- 各种各样的 HTTP 首部都是用来做什么的

### 报文流
报文在客户端、服务器和代理之间流动。术语“流入”、“流出”、“上游”以及“下游”都是用来描述报文方向的。

+ 报文流入源服务器，工作完成之后，会流回用户的 Agent 代理中，HTTP 报文会像河水一样流动，不管是请求还是响应报文，都会向下游流动，所有报文的发送者都在接收者的上游。

### 报文的组成
HTTP 报文是简单的格式化数据块。每条报文由三部分组成，对报文进行描述的**起始行**、包含属性的**首部**快、以及可选的、包含数据的**主体**部分

+ 起始行和首部是由行分割的 ASCII 文本。每行都以一个由两个字符组成的终止符组成的行终止序列作为结束，其中包括一个回车符和一个换行符。这个行终止序列可以写作 CRLF，但是有些 HTTP 应用程序并不总是既发送回车符，又发送换行符。

### 报文的语法
所有的 HTTP 报文都可以分为两类：**请求报文** 和 **响应报文**

+ 请求报文格式：
```xml
  <method><request-URL><version>
  <headers>

  <entity-body>
```
<br>

+ 响应报文格式：
```xml
  <version><status><reason-phrase>
  <headers>

  <entity-body>
```

**对各个部分的简要概述**

+ 方法（method）
> 客户端希望服务器对资源执行的动作。是一个单独的单词，比如 GET、 HEAD、 POST

+ 请求 URL (request-URL)
> 命名了所请求资源，或者 URL 路径组件的完整 URL，与服务器对话，只要 URL 的路径组件是资源的绝对路径，通常不会有问题。服务器可以假定自己是 URL 的主机/端口。详见[第二章](./chapter_two.md)

+ 版本（version）
> 报文所使用的 HTTP 版本，格式如下：
```xml
  HTTP/<major>.<minor>
```

+ 状态码（status-code）
> 这个三位数字描述了请求过程中所发生的情况，每个状态码的第一个数字用于描述状态的一般类别（“成功”、“出错”等，也就是 1xx、2xx、3xx、4xx、5xx）

+ 原因短句（reason-phrase）
> 原因短句只对人类有意义。因此，比如说，尽管响应行 `HTTP/1.0 200 NOT OK` 和 `HTTP/1.0 200 OK` 中的原因断句不同，但都会被当作成功指示处理

+ 首部（header）
> 可以有零个或多个首部，首部由一个名字，后面跟着一个 `:`，然后是一个可选的空格，接着是一个值，最后是一个 CRLF，首部是由一个空行（CRLF）结束的。有些 HTTP 版本，比如 HTTP/1.1，要求有效的请求或响应报文中必须包含特定的首部

+ 实体的主体部分（entity-body）
> 实体的主体部分包含一个由任意数据组成的数据块，并不是所有的报文都包含实体的主体部分，有时，报文只是以一个 CRLF 结束


### 起始行
以下为假想的请求和响应报文

```
                (a) 请求报文                                  (b) 响应报文                 
  ----------------------------------            ----------------------------------- 
  | GET /testhi-there.txt HTTP/1.1 |  起始行     | HTTP/1.0 200 OK                 |
  |--------------------------------|            |---------------------------------|
  | Accept: text/*                 |            | Content-type: text/plain        |
  | Host: www.joes-hardware.com    |   首部      | Content-Length: 19              |
  |--------------------------------|            |---------------------------------|
                                                |                                 |
                                                | Hi! I'm a message!              |
                                       主体      |---------------------------------|

```

+ 请求行的起始行以方法作为开始，用来告知服务器要做什么，有些方法中包含了主体，有些不包含，以下是常用的 HTTP 方法

| 方法      | 描述                        | 是否包含主体 |
|---------|---------------------------|--------|
| GET     | 从服务器获取一份稳定                | 否      |
| HEAD    | 只从服务器获取文档的首部              | 否      |
| POST    | 向服务器发送需要处理的数据             | 是      |
| PUT     | 将请求的主体部分存储到服务器上           | 是      |
| TRACE   | 对可能经过代理服务器传送到服务器上去的报文进行追踪 | 否      |
| OPTIONS | 决定可以在服务器上执行哪些方法           | 否      |
| DELETE  | 从服务器上删除一份文档               | 否      |

+ 状态码的分类

| 整体范围      | 已定义范围     | 分类    |
|-----------|-----------|-------|
| 100 ~ 199 | 100 ~ 101 | 信息提示  |
| 200 ~ 299 | 200 ~ 206 | 成功    |
| 300 ~ 399 | 300 ~ 305 | 重定向   |
| 400 ~ 499 | 400 ~ 415 | 客户端错误 |
| 500 ~ 599 | 500 ~ 505 | 服务器错误 |

### 首部
HTTP 首部字符向请求和响应报文中添加了一些附加信息。本质上来说，它们只是一些名 `key/value` 对的列表。HTTP 规范定义了几种首部，但是应用程序也可以随意发明自己所用的首部，HTTP 首部可以分为以下几类

+ 通用首部
> 既可以出现在请求报文中，也可以出现在响应报文中

+ 请求首部
> 提供更多有关请求的信息

+ 响应首部
> 提供更多有关响应的信息

+ 实体首部
> 描述主体的长度和内容，或者资源本身

+ 扩展首部
> 规范中没有定义的新首部

每个 HTTP 首部都有一种简单的语法：
```
  名字后面跟着冒号（:），然后跟上可以选的空格，再跟上字段值，最后是一个 CRLF
```

**首部延续行**：将长的首部行分为多行可以提高可读性，多出来的每行前面至少要有一个空格或者制表符。例如：
```
  Server: Test Server
    Version 1.0
```

### 实体的主体部分

HTTP 报文的第三部分是可选的实体主体部分。实体的主体是 HTTP 报文的负荷。就是 HTTP 要传输的内容。HTTP 报文可以承载很多类型的数字类型：图片、视频、HTML 文档、软件应用程序、信用卡事务、电子邮件等

### 方法（详细描述）

+ **安全方法**<br>
HTTP 定义了一组被称为安全方法的方法。GET 和 HEAD 方法都被认为是安全的，这以为这 GET 和 HEAD 方法的 HTTP 请求不会产生什么动作（也就是不会对服务器产生一些行为，比如服务存储、删除、更改资源等，那 POST 之类的方法就会产生一些行为）<br>
安全方法并不一定是什么动作都不执行（实际上这由 web 开发者决定）。使用安全方法的目的就是当使用可能引发某一动作的不安全方法时，允许 HTTP 应用程序开发者通知用户，比如用不安全的方法发起请求，会在服务器上产生一些事件（你的信用卡支付费用）

+ **GET**<br>
GET 是最常用的方法。通常用于请求服务器发送某个资源。HTTP/1.1 要求服务器实现此方法
<br><br>
```
    请求报文
  |----------------------------------------|
  | GET /seasonal/index-fall.html HTTP/1.1 |
  | Host: www.joes-hardware.com            |
  | Accept: *                              |
  |----------------------------------------|

    响应报文
  |---------------------------------------------|
  | HTTP/1.1 200 OK                             |
  | Content-Type: text/html                     |
  | Content-Length: 617                         |
  |                                             |
  | <HTML>                                      |
  | <HEAD><TITLE> Joeos Special Offers </TITLE> |
  | ...                                         |
  |---------------------------------------------|
```

+ **HEAD**<br>
HEAD 方法与 GET 方法行为类似，但服务器在响应中只返回首部，不会返回实体的主体部分，这样就允许客户端为获取实际资源的情况下，对资源的首部进行检查，HTTP/1.1 规范，必须实现 HEAD 方法。使用 HEAD，可以：
  1) 在不获取资源的情况下了解资源情况（比如判断其类型）
  2) 通过查看响应首部的状态码，看看某个对象是否存在
  3) 通过查看首部，测试资源是否被修改了
<br><br>
```
    请求报文
  |-----------------------------------------|
  | HEAD /seasonal/index-fall.html HTTP/1.1 |
  | Host: www.joes-hardware.com             |
  | Accept: *                               |
  |-----------------------------------------|

    响应报文（没有实体的主体部分）
  |-----------------------------------------|
  | HTTP/1.1 200 OK                         |
  | Content-Type: text/html                 |
  | Content-Length: 617                     |
  |-----------------------------------------|
```

+ **PUT**<br>
与 GET 从服务器读取文档相反，PUT 方法会向服务器写入文档。有些发布系统允许用户创建 web 页面，并用 PUT 直接将其安装到 web 服务器上去。PUT 方法的语义就是让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，如果那个 URL 已经存在，就用这个主体替代它。<br>
因为 PUT 方法允许用户对内容进行修改，所以很多 web 服务器都要求在执行 PUT 之前，用密码登录。详情见[第十二章](../three_part/chapter_twelve.md)
<br><br>
```
    请求报文
  |----------------------------------------|
  | PUT /product-list.txt HTTP/1.1         |
  | Host: www.joes-hardware.com            |
  | Content-type: text/plain               |
  | Content-Length: 34                     |
  |                                        |
  | Updated product list coming soon!      |
  |----------------------------------------|

    响应报文（服务器更新/创建资源/product-list.txt，并将其写入自己的磁盘）
  |---------------------------------------------------------|
  | HTTP/1.1 201 Created                                    |
  | Location: http://www.joes-hardware.com/product-list.txt |
  | Content-Type: text/plain                                |
  | Content-Length: 47                                      |
  |                                                         |
  | http://www.joes-hardware.com/product-list.txt           |
  |---------------------------------------------------------|
```

+ **POST**<br>
POST 方法起初是用来向服务器输入数据的（POST 用于向服务器发送数据，PUT 用于向服务器上的资源`例如文件`中存储数据），实际上，通常会用它来支持 HTML 中的表单（但是我感觉现在 xhr 用的多些，表单都不怎么用了，虽然用表单没有跨域，但是很难做到无刷新）。

+ **TRACE**<br>
客户端发起一个请求时，这个请求可能会穿过防火墙、代理、网关或者其他一些应用程序。每个中间节点都可能会修改原始的 HTTP 请求。TRACE 方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子<br>
TRACE 请求会在目的地服务器端发起一个 “环回” 诊断。行程最后一站的服务器会弹回一条 TRACE 响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看所有 HTTP 中间应用程序的请求/响应链上，原始报文是否、以及、如何被毁坏或修改
<br><br>
```
    请求报文          
  |----------------------------------|            |----------------------------------|
  | TRACE /product-list.txt HTTP/1.1 |  经过代理    | TRACE /product-list.txt HTTP/1.1 | 
  | Accept: *                        | -------->  | Host: www.joes-hardware.com      |
  | Host: www.joes-hardware.com      |            | Accept: *                        |
  |----------------------------------|            | Via: 1.1 proxy3.company.com      |
                                                  |----------------------------------| 
                                                                  |
                                                                  |
                                                                  v
                                                    响应报文
  |----------------------------------|            |----------------------------------|
  | HTTP/1.1 200 OK                  |            | HTTP/1.1 200 OK                  |
  | Content-Type: text/plain         |            | Content-Type: text/plain         |
  | Content-Length: 96               |            | Content-Length: 96               |
  | Via: 1.1 proxy3.company.com      |  经过代理    |                                  |
  |                                  | <--------  | TRACE /product-list.txt HTTP/1.1 |
  | TRACE /product-list.txt HTTP/1.1 |            | Host: www.joes-hardware.com      |
  | Host: www.joes-hardware.com      |            | Accept: *                        |
  | Accept: *                        |            | Via: 1.1 proxy3.company.com      |
  | Via: 1.1 proxy3.company.com      |            |----------------------------------|
  |----------------------------------|
```
TRACE 方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链，也可以用来查看代理和其他应用程序对用户请求所产生的效果<br>
但是它也有缺点，它假定中间应用程序对各种不同类型请求（GET、POST、HEAD等）的处理是相同的。比如代理可能会将 POST 请求直接发送给服务器，将 GET 请求发送给另外一个 HTTP 应用程序（比如 web 缓存），TRACE 并不提供区分这些方法的机制。通常，中间应用程序会自行决定对 TRACE 请求的处理方式<br><br>

TRACE 请求中不能带有实例的主体部分。TRACE 响应的实体主体部分包含了响应服务器收到的请求的精确副本

+ **OPTIONS**<br>
OPTIONS 方法请求 web 服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法（有些服务器可能只支持对一些特殊类型的对象使用特定的操作）<br>
这为客户端提供了一种手段，使其不用实际访问资源就能判定访问各种资源的最优方式
<br><br>
```
    请求报文                                    响应报文
  |-----------------------------|           |--------------------------------|   由于请求的是可为所有资源
  | OPTIONS * HTTP/1.1          |           | HTTP/1.1 200 OK                |   使用的选项，所以服务器仅
  | Host: www.joes-hardware.com |           | Allow: GET, POST, PUT, OPTIONS |   返回了它支持的可通用于各
  | Accept: *                   |           | Content-Length: 0              |   种资源的方法
  |-----------------------------|           |--------------------------------|
```

+ **DELETE**<br>
DELETE 方法所做的事情就是请服务器删除请求 URL 所指定的资源。但是，客户端应用程序无法保证删除操作一定会被执行。因为 HTTP 规范允许服务器在不通知客户端的情况下撤销请求
<br><br>
```
    请求报文（客户端认为资源以及被删除了）                 响应报文
  |-----------------------------------|           |-----------------------------|
  | DELETE /product-list.txt HTTP/1.1 |  ---->    | HTTP/1.1 200 OK             |  从服务器磁盘中删除文件
  | Host: www.joes-hardware.com       |           | Content-Type: text/plain    |  product-list.txt
  |-----------------------------------|  <----    | Content-Length: 54          |
                                                  |                             |
                                                  | I have your delete request, |
                                                  | will take time to process.  |
                                                  |-----------------------------|
```

+ **扩展方法**<br>
HTTP 被设计成字段可扩展的，这样新的特性就不会使老的软件失效了。扩展方法指的就是没有在 HTTP/1.1 规范中定义的方法。以下为一些常用的扩展方法：

| 方法    | 描述                                        |
|-------|-------------------------------------------|
| LOCK  | 允许用户“锁定”资源 -- 比如在编辑某个资源的时候将其锁定，防止别人同时对其修改 |
| MKCOL | 允许用户创建资源                                  |
| COPY  | 便于在服务器上复制资源                               |
| MOVE  | 在服务器上移动资源                                 |

并不是所有的扩展方法都是在正式规范中定义的。所以最好对扩展方法宽容一些，如果能够在不破坏端到端行为的情况下，代理应该尝试传递这些报文，如果可能会破坏端到端行为，则应该以 `501 Not Implemented` 状态码进行响应。按照惯例，“对所发送的内容要求严一点，对所接收的内容宽容一点” 来处理扩展方法


## 状态码
HTTP 状态码被分为五大类

+ **100 ~ 199 -- 信息性状态码**<br>
HTTP/1.1 向协议引入了信息性状态码，关于其复杂性和感知价值存在一些争论，而受到限制。以下为已定义的状态码：
```html
  ------------------------------------------------------------------------------------------------------
    状态码 |       原因短句       |                                 含 义                                 |
  ------------------------------------------------------------------------------------------------------
    100   |       Continue      | 说明收到请求的初始部分，请求客户端继续，发送了这个状态码之后，服务器在收到请求之后 |
          |                     | 必须进行响应。更多信息见附录 C 中的 Expect 首部介绍                         |
  -----------------------------------------------------------------------------------------------------|
    101   | Switching Protocols | 说明服务器正在根据客户端的指定，将协议切换成 Update 首部所列的协议             |
  ------------------------------------------------------------------------------------------------------  
```

`100 Continue` 会让人很糊涂，所以这里进行详细解释

1) **客户端与 100 Continue**<br>
如果客户端在向服务器发送一个实体，并且愿意在发送实体之前等待 `100 Continue` 响应，那么客户端就要发送一个携带了值为 `100 Continue` 的 Expect 请求首部。如果客户端没有发送实体，就不应该发送 `100 Continue Expect` 首部，因为这样会让服务器产生误会
<br>
从很多方面来看，`100 Continue` 都是一种优化，客户端应该在发送一个服务器无法处理或者使用大实体时，才应该使用 `100 Contine`，而且客户端发送了值为 `100 Continue` 的 Expect 首部的时候不应该永远在那儿等待服务器发送 `100 Continue` 响应，超过一定时间之后，客户端应该直接将实体发送出去。客户端程序实现者还应该做好应对非预期的 `100 Continue` 响应，有些出错的 HTTP 应用程序会不合时宜的发送这个状态码

2）**服务器与 100 Continue**<br>
如果服务器收到了一条带有值为 `100 Continue` 的 Expect 首部请求，它会用 `100 Continue` 响应或者一条错误码来响应。服务器永远不应该向没有发送 `100 Continue` 期望的客户端发送 `100 Continue` 状态码（有些出错服务器会这么做）
<br>
如果服务器在有机会发送 `100 Continue` 响应之前就收到了部分或者全部的实体，说明客户端已经决定继续发送数据了，这样，服务器就不需要发送这个状态码了，但服务器读完请求之后，还是应该为请求发送一个最终状态码（可以跳过 `100 Continue` 状态）
<br>
最后，如果服务器收到了带有 `100 Continue` 期望的请求，而且它决定在读取实体主体部分之前结束请求（比如出错），就不应该仅仅是发送一条响应并关闭连接，因为这样会妨碍客户端接收响应，详见[第四章](./chapter_four.md)

3) **代理与100 Continue**<br>
如果代理收到了一条带有 xx 的请求，它需要做几件事。如果代理知道[下一跳服务器](../two_part/chapter_six.md)是 HTTP/1.1 兼容的，或并不知道下一跳服务器与哪个版本兼容，它都应该将 Expect 首部放在请求中向下转发。如果它知道下一跳服务器只能与 HTTP/1.1 之前的版本兼容，就应该以 `417 Expectation Failed` 错误进行响应（还有一种合理的方法，是先向客户端返回 `100 Continue`， 然后删除 Expect 首部，再向服务器转发）<br>
如果代理决定与 HTTP/1.0 或之前版本兼容的客户端，在其请求中放入 Expect 首部和 `100 Continue` 值，那么它就不应该将 `100 Continue` 响应转发给客户端，因为客户端可能不知道该拿它怎么办


+ **200 ~ 299 -- 成功状态码**<br>
以下列出了已定义的成功状态码
```html
  ---------------------------------------------------------------------------------------------------------
  状态码 |  原因短句   |                                 含 义                                               |
  ---------------------------------------------------------------------------------------------------------
    200 |    OK      | 请求没问题，实体的主体部分包含了所请求的资源                                               |
  ---------------------------------------------------------------------------------------------------------
    201 |  Created   | 用于创建服务器对象的请求（比如 PUT）。响应的实体主体部分中应该包含各种引用了已创建的资源的 URL，  |
        |            | [Location 首部](./#dfasdfsdaf)包含的则是最具体的引用。服务器必须在发送这个状态码之前创建好对象 |
  --------------------------------------------------------------------------------------------------------- 
    202 | Accepted   | 请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求；这只是意味着接受请求时，它 |      |            | 看起来是有效的。服务器应该在实体的主体部分包含对请求状态的描述，或许还应该有对请求完成时间的估计（或 |
        |            | 者包含一个指针，指向可以获取此信息的位置                                                   |
  ----------------------------------------------------------------------------------------------------------
    203 | Non-Author | 实体首部包含的信息不是来自源服务器，而是来自资源的一份副本。如果中间节点上有一份资源副本，但无法或者 |      | itative    | 没有对它所发送的与资源有关的元信息（首部）进行验证，就会出现这种情况。这种响应并不是非用不可；如果实 |
        | Information| 体首部来自源服务器，响应为 200 状态的应用程序就可以将其作为一种可选性使用                      |
  ----------------------------------------------------------------------------------------------------------
    204 | No Content | 响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要用于在浏览器不转为显示新文档的情况下，|
        |            | 对其进行更新（比如刷新一个表单页面）                                                     |
  ----------------------------------------------------------------------------------------------------------
    205 |   Reset    | 另一个主要用于浏览器的代码。负责告知浏览器清除当前页面中的所有 HTML 表单元素                   |
        |  Content   |                                                                                    |
  ----------------------------------------------------------------------------------------------------------
    206 |  Partial   | 成功执行了一部分或 Range 请求。客户端可以通过一些特殊的首部来获取部分或者某个范围内的文档 -- 这个 |
        |  Content   | 状态码就说明范围请求成功了。206 响应中必须包含 Content-Range、Date、Etag 或 Content-Locatin |
        |            | 更多见第[十五章](../four_part/chapter_fifteen.md)
  ----------------------------------------------------------------------------------------------------------
```